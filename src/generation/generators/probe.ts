/**
 * probe Graph Class Generators
 *
 * AUTO-GENERATED by scripts/codegen/generate-graph-classes.ts
 * DO NOT EDIT MANUALLY
 *
 * @generated 2026-01-18T16:10:41.826Z
 */

import type { GraphSpec } from "../spec.js";
import type { SeededRandom, TestEdge, TestNode } from "./types.js";

const addEdgeIfNotExists = (
	edges: TestEdge[],
	source: string,
	target: string
): void => {
	const exists = edges.some(
		(e) =>
			(e.source === source && e.target === target) ||
			(e.source === target && e.target === source)
	);
	if (!exists) {
		edges.push({ source, target });
	}
};

/**
 * Generate ProbeChordal edges.
 * @param nodes
 * @param edges
 * @param spec
 * @param rng
 */
export const generateProbeChordalEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	const probeChordal = spec as unknown as { probeChordal?: { kind: string } };
	if (probeChordal.probeChordal?.kind !== "probe_chordal") {
		throw new Error("ProbeChordal generation requires probe_chordal spec");
	}

	// Strategy: Generate chordal graph, then randomly designate some vertices as "probes"
	// For simplicity, generate chordal graph using PEO (all chordal graphs are probe chordal)
	const nodeCount = nodes.length;
	if (nodeCount < 2) return;

	// Perfect elimination ordering
	const order = nodes.map((_, index) => index);
	for (let index = order.length - 1; index > 0; index--) {
		const index_ = rng.integer(0, index);
		[order[index], order[index_]] = [order[index_], order[index]];
	}

	for (let index = 0; index < order.length; index++) {
		const v = nodes[order[index]];
		const maxNeighbors = Math.min(3, order.length - index - 1);

		for (let k = 0; k < maxNeighbors; k++) {
			if (index + k + 1 >= order.length) break;
			const targetIndex = index + rng.integer(1, Math.min(3, order.length - index - 1));
			addEdgeIfNotExists(edges, v.id, nodes[targetIndex].id);
		}
	}
};

/**
 * Generate ProbeInterval edges.
 * @param nodes
 * @param edges
 * @param spec
 * @param rng
 */
export const generateProbeIntervalEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	const probeInterval = spec as unknown as { probeInterval?: { kind: string } };
	if (probeInterval.probeInterval?.kind !== "probe_interval") {
		throw new Error("ProbeInterval generation requires probe_interval spec");
	}

	// Strategy: Generate interval graph (all interval graphs are probe interval)
	const nodeCount = nodes.length;
	if (nodeCount < 2) return;

	// Assign random intervals on line
	const intervals: Array<{ start: number; end: number }> = [];
	for (let index = 0; index < nodeCount; index++) {
		const start = rng.next();
		const length = rng.next() * 0.5;
		intervals.push({ start, end: start + length });
	}

	// Connect intersecting intervals
	for (let index = 0; index < nodeCount; index++) {
		for (let index_ = index + 1; index_ < nodeCount; index_++) {
			const [a, b] = [intervals[index], intervals[index_]];
			if (!(a.end < b.start || b.end < a.start)) {
				addEdgeIfNotExists(edges, nodes[index].id, nodes[index_].id);
			}
		}
	}
};
