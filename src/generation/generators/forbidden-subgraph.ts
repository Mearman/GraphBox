/**
 * forbidden_subgraph Graph Class Generators
 *
 * AUTO-GENERATED by scripts/codegen/generate-graph-classes.ts
 * DO NOT EDIT MANUALLY
 */

import {
	buildAdjacencyList,
	hasInducedSubgraph,
	SUBGRAPH_PATTERNS
} from "../../algorithms/extraction/forbidden-subgraphs.js";
import type { GraphSpec } from "../spec.js";
import type { SeededRandom, TestEdge, TestNode } from "./types.js";

/**
 * Add edge if it doesn't create a multi-edge.
 * @param edges
 * @param source
 * @param target
 */
const addEdgeIfNotExists = (
	edges: TestEdge[],
	source: string,
	target: string
): void => {
	const exists = edges.some(
		(edge) =>
			(edge.source === source && edge.target === target) ||
			(edge.source === target && edge.target === source)
	);
	if (!exists) {
		edges.push({ source, target });
	}
};

/**
 * Check if current edge set contains a forbidden subgraph.
 * @param nodes
 * @param edges
 * @param pattern
 */
const _hasForbiddenSubgraph = (
	nodes: TestNode[],
	edges: TestEdge[],
	pattern: typeof SUBGRAPH_PATTERNS[keyof typeof SUBGRAPH_PATTERNS]
): boolean => {
	if (nodes.length < pattern.size) {
		return false;
	}

	// Build adjacency list
	const nodeIdMap = new Map<string, number>();
	for (const [index, n] of nodes.entries()) {
		nodeIdMap.set(n.id, index);
	}

	const vertexSet = new Set(nodes.map((_, index) => index));
	const edgeList = edges.map((edge) => {
		const source = nodeIdMap.get(edge.source);
		const tgt = nodeIdMap.get(edge.target);
		return source !== undefined && tgt !== undefined ? ([source, tgt] as [number, number]) : null;
	}).filter((edge): edge is [number, number] => edge !== null);

	const adjacency = buildAdjacencyList(vertexSet, edgeList);
	return hasInducedSubgraph(adjacency, pattern);
};

/**
 * Generate P5Free edges.
 * Contains no induced path on 5 vertices
 * Uses cograph construction (P4-free implies P5-free).
 * @param nodes
 * @param edges
 * @param spec
 * @param rng
 */
export const generateP5FreeEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	if (spec.p5Free?.kind !== "p5_free") {
		throw new Error("P5Free generation requires p5_free spec");
	}

	const nodeCount = nodes.length;

	// Generate as cograph (union of cotree construction)
	// Simple approach: Start with disjoint union, randomly merge components
	if (nodeCount <= 1) {
		return;
	}

	// Initialize each vertex as its own component
	const components: TestNode[][] = nodes.map((n) => [n]);

	// Randomly merge components until one remains
	while (components.length > 1) {
		// Pick two random components
		const index = rng.integer(0, components.length - 1);
		let index_ = rng.integer(0, components.length - 1);
		while (index === index_) {
			index_ = rng.integer(0, components.length - 1);
		}

		const comp1 = components[index];
		const comp2 = components[index_];

		// Operation: join (add all edges between) or union (no edges)
		const operation = rng.next() > 0.5 ? "join" : "union";

		if (operation === "join") {
			// Add all edges between comp1 and comp2
			for (const n1 of comp1) {
				for (const n2 of comp2) {
					addEdgeIfNotExists(edges, n1.id, n2.id);
				}
			}
		}
		// Union: no edges to add

		// Merge components
		comp1.push(...comp2);
		components.splice(index_, 1);
	}
};

/**
 * Generate C5Free edges.
 * Contains no induced cycle on 5 vertices
 * Uses chordal graph construction (no induced cycles >= 4).
 * @param nodes
 * @param edges
 * @param spec
 * @param rng
 */
export const generateC5FreeEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	if (spec.c5Free?.kind !== "c5_free") {
		throw new Error("C5Free generation requires c5_free spec");
	}

	const nodeCount = nodes.length;

	if (nodeCount < 2) {
		return;
	}

	// Generate chordal graph using perfect elimination ordering
	// Process vertices in reverse order, each connects to random subset of later vertices
	const order = nodes.map((_, index) => index);

	// Shuffle order
	for (let index = order.length - 1; index > 0; index--) {
		const index_ = rng.integer(0, index);
		[order[index], order[index_]] = [order[index_], order[index]];
	}

	// For each vertex (in reverse order), connect to random subset of vertices after it
	for (let index = 0; index < order.length; index++) {
		const v = nodes[order[index]];

		// Choose random number of neighbors from vertices after i
		const maxNeighbors = Math.min(3, order.length - index - 1);
		const numberNeighbors = rng.integer(0, maxNeighbors);

		// Select random neighbors
		const candidates = order.slice(index + 1);
		for (let k = 0; k < numberNeighbors; k++) {
			if (candidates.length === 0) break;
			const index = rng.integer(0, candidates.length - 1);
			const targetIndex = candidates[index];
			candidates.splice(index, 1);
			addEdgeIfNotExists(edges, v.id, nodes[targetIndex].id);
		}
	}
};

/**
 * Generate BullFree edges.
 * Contains no induced bull graph
 * Uses split graph construction (clique + independent set).
 * @param nodes
 * @param edges
 * @param spec
 * @param rng
 */
export const generateBullFreeEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	if (spec.bullFree?.kind !== "bull_free") {
		throw new Error("BullFree generation requires bull_free spec");
	}

	const nodeCount = nodes.length;

	if (nodeCount < 2) {
		return;
	}

	// Split graph: partition into clique and independent set
	const cliqueSize = Math.max(1, Math.floor(nodeCount * rng.next()));
	const shuffled = [...nodes].sort(() => rng.next() - 0.5);

	const clique = shuffled.slice(0, cliqueSize);
	const independentSet = shuffled.slice(cliqueSize);

	// Add all edges within clique (complete graph)
	for (let index = 0; index < clique.length; index++) {
		for (let index_ = index + 1; index_ < clique.length; index_++) {
			addEdgeIfNotExists(edges, clique[index].id, clique[index_].id);
		}
	}

	// Add random edges between clique and independent set
	for (const c of clique) {
		for (const ind of independentSet) {
			if (rng.next() > 0.3) {
				addEdgeIfNotExists(edges, c.id, ind.id);
			}
		}
	}

	// No edges within independent set
};

/**
 * Generate GemFree edges.
 * Contains no induced gem graph
 * Gem is a P4 with a chord, so generate chordal graph avoiding gem.
 * @param nodes
 * @param edges
 * @param spec
 * @param rng
 */
export const generateGemFreeEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	if (spec.gemFree?.kind !== "gem_free") {
		throw new Error("GemFree generation requires gem_free spec");
	}

	// Generate interval graph (which is gem-free)
	const nodeCount = nodes.length;

	if (nodeCount < 2) {
		return;
	}

	// Assign random intervals on line
	const intervals: Array<{ start: number; end: number }> = [];
	for (let index = 0; index < nodeCount; index++) {
		const start = rng.next();
		const length = rng.next();
		intervals.push({ start, end: start + length });
	}

	// Connect intersecting intervals
	for (let index = 0; index < nodeCount; index++) {
		for (let index_ = index + 1; index_ < nodeCount; index_++) {
			const [a, b] = [intervals[index], intervals[index_]];
			// Check if intervals intersect
			if (!(a.end < b.start || b.end < a.start)) {
				addEdgeIfNotExists(edges, nodes[index].id, nodes[index_].id);
			}
		}
	}
};

/**
 * Generate ATFree edges.
 * No asteroidal triple of vertices
 * Uses caterpillar tree construction.
 * @param nodes
 * @param edges
 * @param spec
 * @param rng
 */
export const generateATFreeEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	if (spec.atFree?.kind !== "at_free") {
		throw new Error("ATFree generation requires at_free spec");
	}

	const nodeCount = nodes.length;

	if (nodeCount < 2) {
		return;
	}

	// Generate caterpillar (tree with a central path)
	const spineSize = Math.max(2, Math.floor(Math.sqrt(nodeCount)));
	const spine: TestNode[] = [];
	const leaves: TestNode[] = [];

	// Randomly assign nodes to spine and leaves
	const shuffled = [...nodes].sort(() => rng.next() - 0.5);
	for (let index = 0; index < nodeCount; index++) {
		if (index < spineSize) {
			spine.push(shuffled[index]);
		} else {
			leaves.push(shuffled[index]);
		}
	}

	// Create path through spine
	for (let index = 0; index < spine.length - 1; index++) {
		addEdgeIfNotExists(edges, spine[index].id, spine[index + 1].id);
	}

	// Attach leaves to random spine vertices
	for (const leaf of leaves) {
		const spineIndex = rng.integer(0, spine.length - 1);
		addEdgeIfNotExists(edges, leaf.id, spine[spineIndex].id);
	}
};

/**
 * Generate HHFree edges.
 * No induced house or hole
 * Uses chordal graph construction (which is HH-free).
 * @param nodes
 * @param edges
 * @param spec
 * @param rng
 */
export const generateHHFreeEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	if (spec.hhFree?.kind !== "hh_free") {
		throw new Error("HHFree generation requires hh_free spec");
	}

	// Chordal graphs are HH-free, reuse C5Free generator
	generateC5FreeEdges(nodes, edges, { ...spec, c5Free: { kind: "c5_free" } }, rng);
};

/**
 * Generate DistanceHereditary edges.
 * Distances preserved in all connected induced subgraphs
 * Uses tree construction (trees are distance-hereditary).
 * @param nodes
 * @param edges
 * @param spec
 * @param rng
 */
export const generateDistanceHereditaryEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	if (spec.distanceHereditary?.kind !== "distance_hereditary") {
		throw new Error("DistanceHereditary generation requires distance_hereditary spec");
	}

	const nodeCount = nodes.length;

	if (nodeCount < 2) {
		return;
	}

	// Generate random tree (distance-hereditary)
	// Start with one vertex
	const visited = new Set<string>([nodes[0].id]);
	const unvisited = new Set(nodes.slice(1).map((n) => n.id));

	// Randomly connect unvisited vertices to tree
	while (unvisited.size > 0) {
		// Pick random unvisited vertex
		const unvisitedArray = [...unvisited];
		const newNode = unvisitedArray[rng.integer(0, unvisitedArray.length - 1)];

		// Pick random visited vertex to connect to
		const visitedArray = [...visited];
		const targetNode = visitedArray[rng.integer(0, visitedArray.length - 1)];

		addEdgeIfNotExists(edges, newNode, targetNode);

		// Mark as visited
		unvisited.delete(newNode);
		visited.add(newNode);
	}
};

/**
 * Generate WeaklyChordal edges.
 * No induced hole or anti-hole of length >= 5
 * Uses split graph construction (which is weakly chordal).
 * @param nodes
 * @param edges
 * @param spec
 * @param rng
 */
export const generateWeaklyChordalEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	// Check if weaklyChordal property exists and is constrained
	const wc = spec as unknown as { weaklyChordal?: { kind: string } };
	if (wc.weaklyChordal?.kind !== "weakly_chordal") {
		throw new Error("WeaklyChordal generation requires weakly_chordal spec");
	}

	// Split graphs are weakly chordal, reuse BullFree generator
	generateBullFreeEdges(nodes, edges, { ...spec, bullFree: { kind: "bull_free" } }, rng);
};
