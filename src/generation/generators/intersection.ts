/**
 * intersection Graph Class Generators
 *
 * AUTO-GENERATED by scripts/codegen/generate-graph-classes.ts
 * DO NOT EDIT MANUALLY
 *
 * @generated 2026-01-18T16:10:41.826Z
 */

import type { GraphSpec } from "../spec.js";
import type { SeededRandom, TestEdge, TestNode } from "./types.js";

/**
 * Add edge if it doesn't exist.
 * @param edges
 * @param source
 * @param target
 */
const addEdgeIfNotExists = (
	edges: TestEdge[],
	source: string,
	target: string
): void => {
	const exists = edges.some(
		(e) =>
			(e.source === source && e.target === target) ||
			(e.source === target && e.target === source)
	);
	if (!exists) {
		edges.push({ source, target });
	}
};

/**
 * Generate CircularArc edges.
 * Intersection graph of arcs on a circle
 * @param nodes
 * @param edges
 * @param spec
 * @param rng
 */
export const generateCircularArcEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	const circularArc = spec as unknown as { circularArc?: { kind: string } };
	if (circularArc.circularArc?.kind !== "circular_arc") {
		throw new Error("CircularArc generation requires circular_arc spec");
	}

	const nodeCount = nodes.length;
	if (nodeCount < 2) {
		return;
	}

	// Generate random arcs on a circle
	// Each arc has a start angle and length
	const arcs: Array<{ start: number; end: number }> = [];

	for (let index = 0; index < nodeCount; index++) {
		const start = rng.next() * 2 * Math.PI; // Random start angle [0, 2π]
		const length = rng.next() * Math.PI; // Random length [0, π]
		arcs.push({ start, end: (start + length) % (2 * Math.PI) });
	}

	// Connect intersecting arcs
	for (let index = 0; index < nodeCount; index++) {
		for (let index_ = index + 1; index_ < nodeCount; index_++) {
			const [a, b] = [arcs[index], arcs[index_]];

			// Check if arcs intersect on the circle
			// Two arcs intersect if they overlap on the circle
			const intersects = arcsIntersect(a, b);

			if (intersects) {
				addEdgeIfNotExists(edges, nodes[index].id, nodes[index_].id);
			}
		}
	}
};

/**
 * Check if two circular arcs intersect.
 * @param a
 * @param a.start
 * @param a.end
 * @param b
 * @param b.start
 * @param b.end
 */
const arcsIntersect = (
	a: { start: number; end: number },
	b: { start: number; end: number }
): boolean => {
	// Normalize angles to [0, 2π)
	const normalize = (angle: number) => {
		while (angle < 0) angle += 2 * Math.PI;
		while (angle >= 2 * Math.PI) angle -= 2 * Math.PI;
		return angle;
	};

	const aStart = normalize(a.start);
	const aEnd = normalize(a.end);
	const bStart = normalize(b.start);
	const bEnd = normalize(b.end);

	// Handle wrap-around cases
	const aContains = (angle: number) => {
		return aStart < aEnd ? angle >= aStart && angle <= aEnd : angle >= aStart || angle <= aEnd;
	};

	const bContains = (angle: number) => {
		return bStart < bEnd ? angle >= bStart && angle <= bEnd : angle >= bStart || angle <= bEnd;
	};

	// Arcs intersect if they overlap
	// This happens if: a contains b's start, or b contains a's start
	return aContains(bStart) || bContains(aStart);
};

/**
 * Generate ProperCircularArc edges.
 * Circular arc graph with no arc containment
 * @param nodes
 * @param edges
 * @param spec
 * @param rng
 */
export const generateProperCircularArcEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	const properCircularArc = spec as unknown as { properCircularArc?: { kind: string } };
	if (properCircularArc.properCircularArc?.kind !== "proper_circular_arc") {
		throw new Error("ProperCircularArc generation requires proper_circular_arc spec");
	}

	const nodeCount = nodes.length;
	if (nodeCount < 2) {
		return;
	}

	// Generate proper circular arcs (no arc fully contains another)
	// Strategy: All arcs have the same length
	const arcLength = (2 * Math.PI) / nodeCount; // Equal lengths

	// Randomly order start positions
	const startAngles: number[] = [];
	for (let index = 0; index < nodeCount; index++) {
		startAngles.push(rng.next() * 2 * Math.PI);
	}

	// Sort to get proper order
	startAngles.sort((a, b) => a - b);

	// Generate arcs
	const arcs: Array<{ start: number; end: number }> = [];
	for (let index = 0; index < nodeCount; index++) {
		const start = startAngles[index];
		arcs.push({ start, end: (start + arcLength) % (2 * Math.PI) });
	}

	// Connect intersecting arcs
	for (let index = 0; index < nodeCount; index++) {
		for (let index_ = index + 1; index_ < nodeCount; index_++) {
			const [a, b] = [arcs[index], arcs[index_]];

			if (arcsIntersect(a, b)) {
				addEdgeIfNotExists(edges, nodes[index].id, nodes[index_].id);
			}
		}
	}
};
