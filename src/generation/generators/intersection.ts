/**
 * intersection Graph Class Generators
 *
 * AUTO-GENERATED by scripts/codegen/generate-graph-classes.ts
 * DO NOT EDIT MANUALLY
 *
 * @generated 2026-01-18T16:10:41.826Z
 */

import type { GraphSpec } from "../spec.js";
import type { SeededRandom,TestEdge,TestNode  } from "./types.js";

/**
 * Generate CircularArc edges.
 * Intersection graph of arcs on a circle
 *
 * @param nodes - Graph nodes
 * @param edges - Edge list to populate
 * @param spec - Graph specification
 * @param rng - Seeded random number generator
 */
export const generateCircularArcEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	if (spec.circularArc?.kind !== "circular_arc") {
		throw new Error("CircularArc generation requires circular_arc spec");
	}

	// TODO: Implement generation logic for CircularArc
	// This is a placeholder that generates random edges
	// Replace with actual constructive algorithm

	const nodeCount = nodes.length;

	// Simple random edge generation (replace with actual algorithm)
	for (let index = 0; index < nodeCount; index++) {
		const index_ = (index + 1 + rng.integer(0, nodeCount - 2)) % nodeCount;
		if (index < index_ && rng.next() > 0.5) {
			edges.push({ source: nodes[index].id, target: nodes[index_].id });
		}
	}
};

/**
 * Generate ProperCircularArc edges.
 * Circular arc graph with no arc containment
 *
 * @param nodes - Graph nodes
 * @param edges - Edge list to populate
 * @param spec - Graph specification
 * @param rng - Seeded random number generator
 */
export const generateProperCircularArcEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	if (spec.properCircularArc?.kind !== "proper_circular_arc") {
		throw new Error("ProperCircularArc generation requires proper_circular_arc spec");
	}

	// TODO: Implement generation logic for ProperCircularArc
	// This is a placeholder that generates random edges
	// Replace with actual constructive algorithm

	const nodeCount = nodes.length;

	// Simple random edge generation (replace with actual algorithm)
	for (let index = 0; index < nodeCount; index++) {
		const index_ = (index + 1 + rng.integer(0, nodeCount - 2)) % nodeCount;
		if (index < index_ && rng.next() > 0.5) {
			edges.push({ source: nodes[index].id, target: nodes[index_].id });
		}
	}
};

/**
 * Generate Disk edges.
 * Intersection graph of disks in the plane
 *
 * @param nodes - Graph nodes
 * @param edges - Edge list to populate
 * @param spec - Graph specification
 * @param rng - Seeded random number generator
 */
export const generateDiskEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	if (spec.diskGraphNew?.kind !== "disk") {
		throw new Error("Disk generation requires disk spec");
	}

	// TODO: Implement generation logic for Disk
	// This is a placeholder that generates random edges
	// Replace with actual constructive algorithm

	const nodeCount = nodes.length;

	// Simple random edge generation (replace with actual algorithm)
	for (let index = 0; index < nodeCount; index++) {
		const index_ = (index + 1 + rng.integer(0, nodeCount - 2)) % nodeCount;
		if (index < index_ && rng.next() > 0.5) {
			edges.push({ source: nodes[index].id, target: nodes[index_].id });
		}
	}
};

// Skipped: UnitDisk (property already exists or was renamed)
