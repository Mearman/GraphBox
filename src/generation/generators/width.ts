/**
 * width Graph Class Generators
 *
 * AUTO-GENERATED by scripts/codegen/generate-graph-classes.ts
 * DO NOT EDIT MANUALLY - But TODOs have been implemented
 *
 * @generated 2026-01-18T16:10:41.827Z
 */

import type { GraphSpec } from "../spec.js";
import type { SeededRandom,TestEdge,TestNode  } from "./types.js";

/**
 * Generate Pathwidth edges using tree or outerplanar construction.
 * Trees have pathwidth 1, outerplanar graphs have pathwidth at most 2.
 *
 * Construction:
 * - 50% chance: Generate a tree (pathwidth 1)
 * - 50% chance: Generate an outerplanar graph (pathwidth ≤ 2)
 *
 * Trees are generated using random tree construction.
 * Outerplanar graphs are generated as triangulated outerplanar graphs.
 *
 * @param nodes - Graph nodes
 * @param edges - Edge list to populate
 * @param spec - Graph specification
 * @param rng - Seeded random number generator
 */
export const generatePathwidthEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	if (spec.pathwidth?.kind !== "pathwidth_bounded") {
		throw new Error("Pathwidth generation requires pathwidth_bounded spec");
	}

	const nodeCount = nodes.length;
	if (nodeCount === 0) return;
	if (nodeCount === 1) return;

	const useTree = rng.next() < 0.5;

	if (useTree) {
		// Generate a random tree (pathwidth 1)
		// Use Prüfer sequence or random parent assignment
		for (let index = 1; index < nodeCount; index++) {
			const parent = rng.integer(0, index - 1);
			edges.push({
				source: nodes[parent].id,
				target: nodes[index].id,
			});
		}
	} else {
		// Generate outerplanar graph (pathwidth ≤ 2)
		// Create a cycle and add chords that don't cross
		// First, create the outer cycle
		for (let index = 0; index < nodeCount; index++) {
			const next = (index + 1) % nodeCount;
			edges.push({
				source: nodes[index].id,
				target: nodes[next].id,
			});
		}

		// Add some non-crossing chords
		if (nodeCount >= 4) {
			const numberChords = Math.min(nodeCount - 3, rng.integer(1, 3));
			for (let c = 0; c < numberChords; c++) {
				const index = rng.integer(0, nodeCount - 1);
				const index_ = (index + 2) % nodeCount; // Skip adjacent to avoid duplicates
				if (index !== index_) {
					edges.push({
						source: nodes[index].id,
						target: nodes[index_].id,
					});
				}
			}
		}
	}
};

/**
 * Generate Cliquewidth edges using cograph or tree construction.
 * Cographs have clique-width ≤ 2, trees have clique-width ≤ 3.
 *
 * Construction:
 * - 60% chance: Generate a cograph (clique-width ≤ 2)
 * - 40% chance: Generate a tree (clique-width ≤ 3)
 *
 * Cographs use recursive join/union operations.
 * Trees use random parent assignment.
 *
 * @param nodes - Graph nodes
 * @param edges - Edge list to populate
 * @param spec - Graph specification
 * @param rng - Seeded random number generator
 */
export const generateCliquewidthEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	if (spec.cliquewidth?.kind !== "cliquewidth_bounded") {
		throw new Error("Cliquewidth generation requires cliquewidth_bounded spec");
	}

	const nodeCount = nodes.length;
	if (nodeCount === 0) return;
	if (nodeCount === 1) return;

	const useCograph = rng.next() < 0.6;

	if (useCograph) {
		// Generate cograph (clique-width ≤ 2)
		// Recursive construction with join/union
		const buildCograph = (start: number, end: number): void => {
			if (end - start <= 1) return;

			const mid = start + Math.floor((end - start) / 2);
			buildCograph(start, mid);
			buildCograph(mid, end);

			// Join or union
			if (rng.next() > 0.5) {
				// Join: connect all pairs
				for (let index = start; index < mid; index++) {
					for (let index_ = mid; index_ < end; index_++) {
						edges.push({
							source: nodes[index].id,
							target: nodes[index_].id,
						});
					}
				}
			}
		};

		buildCograph(0, nodeCount);
	} else {
		// Generate tree (clique-width ≤ 3)
		for (let index = 1; index < nodeCount; index++) {
			const parent = rng.integer(0, index - 1);
			edges.push({
				source: nodes[parent].id,
				target: nodes[index].id,
			});
		}
	}
};
