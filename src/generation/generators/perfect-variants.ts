/**
 * perfect_variants Graph Class Generators
 *
 * AUTO-GENERATED by scripts/codegen/generate-graph-classes.ts
 * DO NOT EDIT MANUALLY - But TODOs have been implemented
 *
 * @generated 2026-01-18T16:10:41.827Z
 */

import type { GraphSpec } from "../spec.js";
import type { SeededRandom,TestEdge,TestNode  } from "./types.js";

/**
 * Generate Modular edges using cograph construction.
 * Modular graphs are cographs: built from single vertices using disjoint union and join.
 *
 * Uses recursive cograph construction:
 * - Base case: Single vertex (modular)
 * - Join operation: Connect all pairs from two sets (creates clique)
 * - Union operation: Keep sets disjoint (creates independent set)
 *
 * @param nodes - Graph nodes
 * @param edges - Edge list to populate
 * @param spec - Graph specification
 * @param rng - Seeded random number generator
 */
export const generateModularEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	if (spec.modular?.kind !== "modular") {
		throw new Error("Modular generation requires modular spec");
	}

	const nodeCount = nodes.length;
	if (nodeCount <= 1) return;

	// Cograph construction via recursive partitioning
	// Split nodes into two groups and either join or keep disjoint
	const buildCograph = (start: number, end: number): void => {
		if (end - start <= 1) return; // Base case: single vertex

		const mid = start + Math.floor((end - start) / 2);

		// Recursively build left and right halves
		buildCograph(start, mid);
		buildCograph(mid, end);

		// Random choice: join (connect all pairs) or union (keep disjoint)
		const shouldJoin = rng.next() > 0.5;

		if (shouldJoin) {
			// Join: connect all vertices in left half to all in right half
			for (let index = start; index < mid; index++) {
				for (let index_ = mid; index_ < end; index_++) {
					edges.push({
						source: nodes[index].id,
						target: nodes[index_].id,
					});
				}
			}
		}
		// If not joining, keep disjoint (union operation - no edges)
	};

	buildCograph(0, nodeCount);
};

/**
 * Generate Ptolemaic edges using block graph construction.
 * Ptolemaic graphs are chordal and distance-hereditary.
 * Block graphs (trees of cliques) satisfy both properties.
 *
 * Construction:
 * - Partition nodes into cliques (blocks)
 * - Connect blocks in a tree structure
 * - Each block is a complete subgraph
 *
 * @param nodes - Graph nodes
 * @param edges - Edge list to populate
 * @param spec - Graph specification
 * @param rng - Seeded random number generator
 */
export const generatePtolemaicEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	if (spec.ptolemaic?.kind !== "ptolemaic") {
		throw new Error("Ptolemaic generation requires ptolemaic spec");
	}

	const nodeCount = nodes.length;
	if (nodeCount === 0) return;
	if (nodeCount === 1) return;

	// Partition nodes into 2-4 blocks (cliques)
	const numberBlocks = Math.min(nodeCount, rng.integer(2, 4));
	const blockSize = Math.floor(nodeCount / numberBlocks);
	const blocks: number[][] = [];

	for (let index = 0; index < numberBlocks; index++) {
		const start = index * blockSize;
		const end = index === numberBlocks - 1 ? nodeCount : (index + 1) * blockSize;
		blocks.push(Array.from({ length: end - start }, (_, index) => start + index));
	}

	// Make each block a clique
	for (const block of blocks) {
		for (let index = 0; index < block.length; index++) {
			for (let index_ = index + 1; index_ < block.length; index_++) {
				edges.push({
					source: nodes[block[index]].id,
					target: nodes[block[index_]].id,
				});
			}
		}
	}

	// Connect blocks in a tree structure (each block connects to next)
	for (let index = 0; index < blocks.length - 1; index++) {
		const u = blocks[index][rng.integer(0, blocks[index].length - 1)];
		const v = blocks[index + 1][rng.integer(0, blocks[index + 1].length - 1)];
		edges.push({
			source: nodes[u].id,
			target: nodes[v].id,
		});
	}
};

/**
 * Generate QuasiLine edges.
 * Quasi-line graphs are either line graphs or complete bipartite.
 * We use a 60/40 mix favoring line graphs.
 *
 * Construction:
 * - 60% chance: Generate a line graph (graph of a base graph's edges)
 * - 40% chance: Generate complete bipartite K_{m,n}
 *
 * @param nodes - Graph nodes
 * @param edges - Edge list to populate
 * @param spec - Graph specification
 * @param rng - Seeded random number generator
 */
export const generateQuasiLineEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	if (spec.quasiLine?.kind !== "quasi_line") {
		throw new Error("QuasiLine generation requires quasi_line spec");
	}

	const nodeCount = nodes.length;
	if (nodeCount === 0) return;
	if (nodeCount === 1) return;

	const useLineGraph = rng.next() < 0.6;

	if (useLineGraph) {
		// Generate line graph: L(G) where nodes are edges of base graph G
		// Create a path or cycle as the base graph
		const basePath: number[] = [];
		for (let index = 0; index < nodeCount; index++) {
			basePath.push(index);
		}

		// Each node in line graph corresponds to an edge in base graph
		// Adjacent if they share a vertex in base graph
		for (let index = 0; index < nodeCount - 1; index++) {
			edges.push({
				source: nodes[index].id,
				target: nodes[index + 1].id,
			});
		}

		// Optionally close the cycle
		if (nodeCount >= 3 && rng.next() > 0.5) {
			edges.push({
				source: nodes[nodeCount - 1].id,
				target: nodes[0].id,
			});
		}
	} else {
		// Generate complete bipartite K_{m,n}
		const m = Math.floor(nodeCount / 2);
		const n = nodeCount - m;

		// Partition nodes
		for (let index = 0; index < m; index++) {
			for (let index_ = m; index_ < nodeCount; index_++) {
				edges.push({
					source: nodes[index].id,
					target: nodes[index_].id,
				});
			}
		}
	}
};
