/**
 * perfect_variants Graph Class Generators
 *
 * AUTO-GENERATED by scripts/codegen/generate-graph-classes.ts
 * DO NOT EDIT MANUALLY - But TODOs have been implemented
 *
 * @generated 2026-01-18T16:10:41.827Z
 */

import type { GraphSpec } from "../spec.js";
import type { SeededRandom,TestEdge,TestNode  } from "./types.js";

/**
 * Generate Modular edges.
 * Modular graphs have no twin vertices (no two vertices with identical external neighborhoods).
 *
 * Generates paths or caterpillar trees to ensure no twins:
 * - Paths: Each vertex has unique position and degree
 * - Caterpillar trees: Main path with leaves attached asymmetrically
 *
 * @param nodes - Graph nodes
 * @param edges - Edge list to populate
 * @param spec - Graph specification
 * @param rng - Seeded random number generator
 */
export const generateModularEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	if (spec.modular?.kind !== "modular") {
		throw new Error("Modular generation requires modular spec");
	}

	const nodeCount = nodes.length;
	if (nodeCount <= 1) return;

	// 70% chance of path, 30% chance of caterpillar tree
	// Always use paths for small graphs to ensure modularity
	const usePath = rng.next() < 0.7 || nodeCount <= 6;

	if (usePath) {
		// Generate a simple path: 0-1-2-3-...-n
		for (let index = 0; index < nodeCount - 1; index++) {
			edges.push({
				source: nodes[index].id,
				target: nodes[index + 1].id,
			});
		}
	} else {
		// Generate caterpillar tree: path with at most one leaf per path node
		// This ensures no two leaves are twins
		const pathLength = Math.ceil(nodeCount / 2);

		// Build main path
		for (let index = 0; index < pathLength - 1; index++) {
			edges.push({
				source: nodes[index].id,
				target: nodes[index + 1].id,
			});
		}

		// Attach leaves: at most one leaf per path node, avoiding twins
		let leafIndex = pathLength;
		for (let index = 0; index < pathLength && leafIndex < nodeCount; index++) {
			// Attach one leaf to this path node
			edges.push({
				source: nodes[index].id,
				target: nodes[leafIndex].id,
			});
			leafIndex++;
		}
	}
};

/**
 * Generate Ptolemaic edges using block graph construction.
 * Ptolemaic graphs are chordal and distance-hereditary.
 * Block graphs (trees of cliques) satisfy both properties.
 *
 * Construction:
 * - Partition nodes into cliques (blocks)
 * - Connect blocks in a tree structure
 * - Each block is a complete subgraph
 *
 * @param nodes - Graph nodes
 * @param edges - Edge list to populate
 * @param spec - Graph specification
 * @param rng - Seeded random number generator
 */
export const generatePtolemaicEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	if (spec.ptolemaic?.kind !== "ptolemaic") {
		throw new Error("Ptolemaic generation requires ptolemaic spec");
	}

	const nodeCount = nodes.length;
	if (nodeCount === 0) return;
	if (nodeCount === 1) return;

	// Simple approach: Create a path with some triangles
	// This is ptolemaic (chordal + distance-hereditary)
	// Build main path
	for (let index = 0; index < nodeCount - 1; index++) {
		edges.push({
			source: nodes[index].id,
			target: nodes[index + 1].id,
		});
	}

	// Add some chords to make small blocks (but keep it ptolemaic)
	// Every 3 nodes, close the triangle if we have enough nodes
	for (let index = 0; index < nodeCount - 2; index += 3) {
		if (index + 2 < nodeCount) {
			edges.push({
				source: nodes[index].id,
				target: nodes[index + 2].id,
			});
		}
	}
};

/**
 * Generate QuasiLine edges.
 * Quasi-line graphs are either line graphs or complete bipartite.
 * We use a 60/40 mix favoring line graphs.
 *
 * Construction:
 * - 60% chance: Generate a line graph (graph of a base graph's edges)
 * - 40% chance: Generate complete bipartite K_{m,n}
 *
 * @param nodes - Graph nodes
 * @param edges - Edge list to populate
 * @param spec - Graph specification
 * @param rng - Seeded random number generator
 */
export const generateQuasiLineEdges = (
	nodes: TestNode[],
	edges: TestEdge[],
	spec: GraphSpec,
	rng: SeededRandom
): void => {
	if (spec.quasiLine?.kind !== "quasi_line") {
		throw new Error("QuasiLine generation requires quasi_line spec");
	}

	const nodeCount = nodes.length;
	if (nodeCount === 0) return;
	if (nodeCount === 1) return;

	const useLineGraph = rng.next() < 0.6;

	if (useLineGraph) {
		// Generate line graph: L(G) where nodes are edges of base graph G
		// Create a path or cycle as the base graph
		const basePath: number[] = [];
		for (let index = 0; index < nodeCount; index++) {
			basePath.push(index);
		}

		// Each node in line graph corresponds to an edge in base graph
		// Adjacent if they share a vertex in base graph
		for (let index = 0; index < nodeCount - 1; index++) {
			edges.push({
				source: nodes[index].id,
				target: nodes[index + 1].id,
			});
		}

		// Optionally close the cycle
		if (nodeCount >= 3 && rng.next() > 0.5) {
			edges.push({
				source: nodes[nodeCount - 1].id,
				target: nodes[0].id,
			});
		}
	} else {
		// Generate complete bipartite K_{m,n}
		const m = Math.floor(nodeCount / 2);

		// Partition nodes
		for (let index = 0; index < m; index++) {
			for (let index_ = m; index_ < nodeCount; index_++) {
				edges.push({
					source: nodes[index].id,
					target: nodes[index_].id,
				});
			}
		}
	}
};
