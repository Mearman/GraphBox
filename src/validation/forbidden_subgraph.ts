/**
 * forbidden_subgraph Graph Class Validators
 *
 * AUTO-GENERATED by scripts/codegen/generate-graph-classes.ts
 * DO NOT EDIT MANUALLY
 *
 * @generated 2026-01-18T16:10:41.824Z
 */

import { buildAdjacencyList, hasInducedSubgraph, SUBGRAPH_PATTERNS } from "../algorithms/extraction/forbidden-subgraphs.js";
import type { TestGraph } from "../generation/generators/types.js";
import type { PropertyValidationResult } from "./types.js";

/**
 * Validate P5Free property.
 * Contains no induced path on 5 vertices
 *
 * @param graph - Test graph to validate
 * @param _adjustments - Optional validation adjustments
 * @returns PropertyValidationResult for validation details
 */
export const validateP5Free = (
	graph: TestGraph,
	_adjustments: Partial<Record<string, boolean>> = {}
): PropertyValidationResult => {
	const { spec, nodes, edges } = graph;
	const expected = spec.p5Free?.kind;

	if (expected === undefined || expected === "unconstrained") {
		return {
			property: "P5Free",
			expected: "unconstrained",
			actual: "unconstrained",
			valid: true,
		};
	}

	// Build adjacency list for subgraph detection
	// Map string node IDs to numbers for subgraph detection
	const nodeIdMap = new Map<string, number>();
	for (const [index, n] of nodes.entries()) nodeIdMap.set(n.id, index);
	const vertexSet = new Set(nodes.map((_, index) => index));
	const edgeList = edges.map((e) => [
		nodeIdMap.get(e.source)!,
		nodeIdMap.get(e.target)!,
	] as [number, number]);
	const adjacency = buildAdjacencyList(vertexSet, edgeList);

	// Check for induced P5 subgraph
	const hasP5 = hasInducedSubgraph(adjacency, SUBGRAPH_PATTERNS.P5);
	const actual = hasP5 ? "has_p5" : "p5_free";

	const valid = actual === expected;

	return {
		property: "P5Free",
		expected,
		actual,
		valid,
		message: valid
			? undefined
			: `Expected ${expected} but found ${actual}`,
	};
};

/**
 * Validate C5Free property.
 * Contains no induced cycle on 5 vertices
 *
 * @param graph - Test graph to validate
 * @param _adjustments - Optional validation adjustments
 * @returns PropertyValidationResult for validation details
 */
export const validateC5Free = (
	graph: TestGraph,
	_adjustments: Partial<Record<string, boolean>> = {}
): PropertyValidationResult => {
	const { spec, nodes, edges } = graph;
	const expected = spec.c5Free?.kind;

	if (expected === undefined || expected === "unconstrained") {
		return {
			property: "C5Free",
			expected: "unconstrained",
			actual: "unconstrained",
			valid: true,
		};
	}

	// Build adjacency list and check for induced C5
	const nodeIdMap = new Map<string, number>();
	for (const [index, n] of nodes.entries()) nodeIdMap.set(n.id, index);
	const vertexSet = new Set(nodes.map((_, index) => index));
	const edgeList = edges.map((e) => [
		nodeIdMap.get(e.source)!,
		nodeIdMap.get(e.target)!,
	] as [number, number]);
	const adjacency = buildAdjacencyList(vertexSet, edgeList);

	const hasC5 = hasInducedSubgraph(adjacency, SUBGRAPH_PATTERNS.C5);
	const actual = hasC5 ? "has_c5" : "c5_free";

	const valid = actual === expected;

	return {
		property: "C5Free",
		expected,
		actual,
		valid,
		message: valid
			? undefined
			: `Expected ${expected} but found ${actual}`,
	};
};

/**
 * Validate BullFree property.
 * Contains no induced bull graph
 *
 * @param graph - Test graph to validate
 * @param _adjustments - Optional validation adjustments
 * @returns PropertyValidationResult for validation details
 */
export const validateBullFree = (
	graph: TestGraph,
	_adjustments: Partial<Record<string, boolean>> = {}
): PropertyValidationResult => {
	const { spec, nodes, edges } = graph;
	const expected = spec.bullFree?.kind;

	if (expected === undefined || expected === "unconstrained") {
		return {
			property: "BullFree",
			expected: "unconstrained",
			actual: "unconstrained",
			valid: true,
		};
	}

	// Build adjacency list and check for induced bull
	const nodeIdMap = new Map<string, number>();
	for (const [index, n] of nodes.entries()) nodeIdMap.set(n.id, index);
	const vertexSet = new Set(nodes.map((_, index) => index));
	const edgeList = edges.map((e) => [
		nodeIdMap.get(e.source)!,
		nodeIdMap.get(e.target)!,
	] as [number, number]);
	const adjacency = buildAdjacencyList(vertexSet, edgeList);

	const hasBull = hasInducedSubgraph(adjacency, SUBGRAPH_PATTERNS.bull);
	const actual = hasBull ? "has_bull" : "bull_free";

	const valid = actual === expected;

	return {
		property: "BullFree",
		expected,
		actual,
		valid,
		message: valid
			? undefined
			: `Expected ${expected} but found ${actual}`,
	};
};

/**
 * Validate GemFree property.
 * Contains no induced gem graph
 *
 * @param graph - Test graph to validate
 * @param _adjustments - Optional validation adjustments
 * @returns PropertyValidationResult for validation details
 */
export const validateGemFree = (
	graph: TestGraph,
	_adjustments: Partial<Record<string, boolean>> = {}
): PropertyValidationResult => {
	const { spec, nodes, edges } = graph;
	const expected = spec.gemFree?.kind;

	if (expected === undefined || expected === "unconstrained") {
		return {
			property: "GemFree",
			expected: "unconstrained",
			actual: "unconstrained",
			valid: true,
		};
	}

	// Build adjacency list and check for induced gem
	const nodeIdMap = new Map<string, number>();
	for (const [index, n] of nodes.entries()) nodeIdMap.set(n.id, index);
	const vertexSet = new Set(nodes.map((_, index) => index));
	const edgeList = edges.map((e) => [
		nodeIdMap.get(e.source)!,
		nodeIdMap.get(e.target)!,
	] as [number, number]);
	const adjacency = buildAdjacencyList(vertexSet, edgeList);

	const hasGem = hasInducedSubgraph(adjacency, SUBGRAPH_PATTERNS.gem);
	const actual = hasGem ? "has_gem" : "gem_free";

	const valid = actual === expected;

	return {
		property: "GemFree",
		expected,
		actual,
		valid,
		message: valid
			? undefined
			: `Expected ${expected} but found ${actual}`,
	};
};

// Skipped: WeaklyChordal (property already exists or was renamed)

/**
 * Validate ATFree property.
 * No asteroidal triple of vertices
 *
 * @param graph - Test graph to validate
 * @param _adjustments - Optional validation adjustments
 * @returns PropertyValidationResult for validation details
 */
export const validateATFree = (
	graph: TestGraph,
	_adjustments: Partial<Record<string, boolean>> = {}
): PropertyValidationResult => {
	const { spec, nodes, edges } = graph;
	const expected = spec.atFree?.kind;

	if (expected === undefined || expected === "unconstrained") {
		return {
			property: "ATFree",
			expected: "unconstrained",
			actual: "unconstrained",
			valid: true,
		};
	}

	// TODO: Implement validation logic for ATFree
	// For now, return placeholder validation
	const actual = "at_free"; // Computed from graph structure

	const valid = actual === expected;

	return {
		property: "ATFree",
		expected,
		actual,
		valid,
		message: valid
			? undefined
			: `Expected ${expected} but found ${actual}`,
	};
};

/**
 * Validate HHFree property.
 * No induced house or hole
 *
 * @param graph - Test graph to validate
 * @param _adjustments - Optional validation adjustments
 * @returns PropertyValidationResult for validation details
 */
export const validateHHFree = (
	graph: TestGraph,
	_adjustments: Partial<Record<string, boolean>> = {}
): PropertyValidationResult => {
	const { spec, nodes, edges } = graph;
	const expected = spec.hhFree?.kind;

	if (expected === undefined || expected === "unconstrained") {
		return {
			property: "HHFree",
			expected: "unconstrained",
			actual: "unconstrained",
			valid: true,
		};
	}

	// TODO: Implement validation logic for HHFree
	// For now, return placeholder validation
	const actual = "hh_free"; // Computed from graph structure

	const valid = actual === expected;

	return {
		property: "HHFree",
		expected,
		actual,
		valid,
		message: valid
			? undefined
			: `Expected ${expected} but found ${actual}`,
	};
};

/**
 * Validate DistanceHereditary property.
 * Distances preserved in all connected induced subgraphs
 *
 * @param graph - Test graph to validate
 * @param _adjustments - Optional validation adjustments
 * @returns PropertyValidationResult for validation details
 */
export const validateDistanceHereditary = (
	graph: TestGraph,
	_adjustments: Partial<Record<string, boolean>> = {}
): PropertyValidationResult => {
	const { spec, nodes, edges } = graph;
	const expected = spec.distanceHereditary?.kind;

	if (expected === undefined || expected === "unconstrained") {
		return {
			property: "DistanceHereditary",
			expected: "unconstrained",
			actual: "unconstrained",
			valid: true,
		};
	}

	// TODO: Implement validation logic for DistanceHereditary
	// For now, return placeholder validation
	const actual = "distance_hereditary"; // Computed from graph structure

	const valid = actual === expected;

	return {
		property: "DistanceHereditary",
		expected,
		actual,
		valid,
		message: valid
			? undefined
			: `Expected ${expected} but found ${actual}`,
	};
};
