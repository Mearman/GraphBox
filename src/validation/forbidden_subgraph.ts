/**
 * forbidden_subgraph Graph Class Validators
 *
 * AUTO-GENERATED by scripts/codegen/generate-graph-classes.ts
 * DO NOT EDIT MANUALLY
 *
 * @generated 2026-01-18T16:10:41.824Z
 */

import { buildAdjacencyList, hasInducedSubgraph, SUBGRAPH_PATTERNS } from "../algorithms/extraction/forbidden-subgraphs.js";
import {
	hasAsteroidalTriple,
	hasInducedCycle,
	isDistanceHereditary,
} from "./forbidden-subgraph-helpers.js";
import type { TestGraph } from "../generation/generators/types.js";
import type { PropertyValidationResult } from "./types.js";

/**
 * Validate P5Free property.
 * Contains no induced path on 5 vertices
 *
 * @param graph - Test graph to validate
 * @param _adjustments - Optional validation adjustments
 * @returns PropertyValidationResult for validation details
 */
export const validateP5Free = (
	graph: TestGraph,
	_adjustments: Partial<Record<string, boolean>> = {}
): PropertyValidationResult => {
	const { spec, nodes, edges } = graph;
	const expected = spec.p5Free?.kind;

	if (expected === undefined || expected === "unconstrained") {
		return {
			property: "P5Free",
			expected: "unconstrained",
			actual: "unconstrained",
			valid: true,
		};
	}

	// Build adjacency list for subgraph detection
	// Map string node IDs to numbers for subgraph detection
	const nodeIdMap = new Map<string, number>();
	for (const [index, n] of nodes.entries()) nodeIdMap.set(n.id, index);
	const vertexSet = new Set(nodes.map((_, index) => index));
	const edgeList = edges.map((e) => [
		nodeIdMap.get(e.source)!,
		nodeIdMap.get(e.target)!,
	] as [number, number]);
	const adjacency = buildAdjacencyList(vertexSet, edgeList);

	// Check for induced P5 subgraph
	const hasP5 = hasInducedSubgraph(adjacency, SUBGRAPH_PATTERNS.P5);
	const actual = hasP5 ? "has_p5" : "p5_free";

	const valid = actual === expected;

	return {
		property: "P5Free",
		expected,
		actual,
		valid,
		message: valid
			? undefined
			: `Expected ${expected} but found ${actual}`,
	};
};

/**
 * Validate C5Free property.
 * Contains no induced cycle on 5 vertices
 *
 * @param graph - Test graph to validate
 * @param _adjustments - Optional validation adjustments
 * @returns PropertyValidationResult for validation details
 */
export const validateC5Free = (
	graph: TestGraph,
	_adjustments: Partial<Record<string, boolean>> = {}
): PropertyValidationResult => {
	const { spec, nodes, edges } = graph;
	const expected = spec.c5Free?.kind;

	if (expected === undefined || expected === "unconstrained") {
		return {
			property: "C5Free",
			expected: "unconstrained",
			actual: "unconstrained",
			valid: true,
		};
	}

	// Build adjacency list and check for induced C5
	const nodeIdMap = new Map<string, number>();
	for (const [index, n] of nodes.entries()) nodeIdMap.set(n.id, index);
	const vertexSet = new Set(nodes.map((_, index) => index));
	const edgeList = edges.map((e) => [
		nodeIdMap.get(e.source)!,
		nodeIdMap.get(e.target)!,
	] as [number, number]);
	const adjacency = buildAdjacencyList(vertexSet, edgeList);

	const hasC5 = hasInducedSubgraph(adjacency, SUBGRAPH_PATTERNS.C5);
	const actual = hasC5 ? "has_c5" : "c5_free";

	const valid = actual === expected;

	return {
		property: "C5Free",
		expected,
		actual,
		valid,
		message: valid
			? undefined
			: `Expected ${expected} but found ${actual}`,
	};
};

/**
 * Validate BullFree property.
 * Contains no induced bull graph
 *
 * @param graph - Test graph to validate
 * @param _adjustments - Optional validation adjustments
 * @returns PropertyValidationResult for validation details
 */
export const validateBullFree = (
	graph: TestGraph,
	_adjustments: Partial<Record<string, boolean>> = {}
): PropertyValidationResult => {
	const { spec, nodes, edges } = graph;
	const expected = spec.bullFree?.kind;

	if (expected === undefined || expected === "unconstrained") {
		return {
			property: "BullFree",
			expected: "unconstrained",
			actual: "unconstrained",
			valid: true,
		};
	}

	// Build adjacency list and check for induced bull
	const nodeIdMap = new Map<string, number>();
	for (const [index, n] of nodes.entries()) nodeIdMap.set(n.id, index);
	const vertexSet = new Set(nodes.map((_, index) => index));
	const edgeList = edges.map((e) => [
		nodeIdMap.get(e.source)!,
		nodeIdMap.get(e.target)!,
	] as [number, number]);
	const adjacency = buildAdjacencyList(vertexSet, edgeList);

	const hasBull = hasInducedSubgraph(adjacency, SUBGRAPH_PATTERNS.bull);
	const actual = hasBull ? "has_bull" : "bull_free";

	const valid = actual === expected;

	return {
		property: "BullFree",
		expected,
		actual,
		valid,
		message: valid
			? undefined
			: `Expected ${expected} but found ${actual}`,
	};
};

/**
 * Validate GemFree property.
 * Contains no induced gem graph
 *
 * @param graph - Test graph to validate
 * @param _adjustments - Optional validation adjustments
 * @returns PropertyValidationResult for validation details
 */
export const validateGemFree = (
	graph: TestGraph,
	_adjustments: Partial<Record<string, boolean>> = {}
): PropertyValidationResult => {
	const { spec, nodes, edges } = graph;
	const expected = spec.gemFree?.kind;

	if (expected === undefined || expected === "unconstrained") {
		return {
			property: "GemFree",
			expected: "unconstrained",
			actual: "unconstrained",
			valid: true,
		};
	}

	// Build adjacency list and check for induced gem
	const nodeIdMap = new Map<string, number>();
	for (const [index, n] of nodes.entries()) nodeIdMap.set(n.id, index);
	const vertexSet = new Set(nodes.map((_, index) => index));
	const edgeList = edges.map((e) => [
		nodeIdMap.get(e.source)!,
		nodeIdMap.get(e.target)!,
	] as [number, number]);
	const adjacency = buildAdjacencyList(vertexSet, edgeList);

	const hasGem = hasInducedSubgraph(adjacency, SUBGRAPH_PATTERNS.gem);
	const actual = hasGem ? "has_gem" : "gem_free";

	const valid = actual === expected;

	return {
		property: "GemFree",
		expected,
		actual,
		valid,
		message: valid
			? undefined
			: `Expected ${expected} but found ${actual}`,
	};
};

// Skipped: WeaklyChordal (property already exists or was renamed)

/**
 * Validate ATFree property.
 * No asteroidal triple of vertices
 *
 * @param graph - Test graph to validate
 * @param _adjustments - Optional validation adjustments
 * @returns PropertyValidationResult for validation details
 */
export const validateATFree = (
	graph: TestGraph,
	_adjustments: Partial<Record<string, boolean>> = {}
): PropertyValidationResult => {
	const { spec, nodes, edges } = graph;
	const expected = spec.atFree?.kind;

	if (expected === undefined || expected === "unconstrained") {
		return {
			property: "ATFree",
			expected: "unconstrained",
			actual: "unconstrained",
			valid: true,
		};
	}

	// Build adjacency list
	const nodeIdMap = new Map<string, number>();
	for (const [index, n] of nodes.entries()) nodeIdMap.set(n.id, index);
	const vertexSet = new Set(nodes.map((_, index) => index));
	const edgeList = edges.map((e) => [
		nodeIdMap.get(e.source)!,
		nodeIdMap.get(e.target)!,
	] as [number, number]);

	const adj = new Map<number, Set<number>>();
	for (const v of vertexSet) {
		adj.set(v, new Set());
	}
	for (const [u, v] of edgeList) {
		adj.get(u)?.add(v);
		adj.get(v)?.add(u);
	}

	// Check all triples of vertices for asteroidal triples
	const vertices = Array.from(vertexSet);
	let hasAT = false;

	for (let i = 0; i < vertices.length && !hasAT; i++) {
		for (let j = i + 1; j < vertices.length && !hasAT; j++) {
			for (let k = j + 1; k < vertices.length && !hasAT; k++) {
				if (hasAsteroidalTriple(adj, vertices[i], vertices[j], vertices[k])) {
					hasAT = true;
				}
			}
		}
	}

	const actual = hasAT ? "has_at" : "at_free";
	const valid = actual === expected;

	return {
		property: "ATFree",
		expected,
		actual,
		valid,
		message: valid
			? undefined
			: `Expected ${expected} but found ${actual}`,
	};
};

/**
 * Validate HHFree property.
 * No induced house or hole (cycle of length >= 5)
 *
 * @param graph - Test graph to validate
 * @param _adjustments - Optional validation adjustments
 * @returns PropertyValidationResult for validation details
 */
export const validateHHFree = (
	graph: TestGraph,
	_adjustments: Partial<Record<string, boolean>> = {}
): PropertyValidationResult => {
	const { spec, nodes: _nodes, edges: _edges } = graph;
	const expected = spec.hhFree?.kind;

	if (expected === undefined || expected === "unconstrained") {
		return {
			property: "HHFree",
			expected: "unconstrained",
			actual: "unconstrained",
			valid: true,
		};
	}

	// Build adjacency list
	const nodeIdMap = new Map<string, number>();
	for (const [index, n] of _nodes.entries()) nodeIdMap.set(n.id, index);
	const vertexSet = new Set(_nodes.map((_, index) => index));
	const edgeList = _edges.map((e) => [
		nodeIdMap.get(e.source)!,
		nodeIdMap.get(e.target)!,
	] as [number, number]);

	const adj = new Map<number, Set<number>>();
	for (const v of vertexSet) {
		adj.set(v, new Set());
	}
	for (const [u, v] of edgeList) {
		adj.get(u)?.add(v);
		adj.get(v)?.add(u);
	}

	// Check for house (5-vertex pattern)
	const adjacency = buildAdjacencyList(vertexSet, edgeList);
	const hasHouse = hasInducedSubgraph(adjacency, SUBGRAPH_PATTERNS.house);

	// Check for holes (cycles of length >= 5)
	let hasHole = false;
	for (let cycleLength = 5; cycleLength <= _nodes.length; cycleLength++) {
		if (hasInducedCycle(adj, vertexSet, cycleLength)) {
			hasHole = true;
			break;
		}
	}

	const actual = hasHouse || hasHole ? "has_hh" : "hh_free";
	const valid = actual === expected;

	return {
		property: "HHFree",
		expected,
		actual,
		valid,
		message: valid
			? undefined
			: `Expected ${expected} but found ${actual}`,
	};
};

/**
 * Validate DistanceHereditary property.
 * Distances preserved in all connected induced subgraphs
 *
 * @param graph - Test graph to validate
 * @param _adjustments - Optional validation adjustments
 * @returns PropertyValidationResult for validation details
 */
export const validateDistanceHereditary = (
	graph: TestGraph,
	_adjustments: Partial<Record<string, boolean>> = {}
): PropertyValidationResult => {
	const { spec, nodes: _nodes, edges: _edges } = graph;
	const expected = spec.distanceHereditary?.kind;

	if (expected === undefined || expected === "unconstrained") {
		return {
			property: "DistanceHereditary",
			expected: "unconstrained",
			actual: "unconstrained",
			valid: true,
		};
	}

	// Build adjacency list
	const nodeIdMap = new Map<string, number>();
	for (const [index, n] of _nodes.entries()) nodeIdMap.set(n.id, index);
	const vertexSet = new Set(_nodes.map((_, index) => index));
	const edgeList = _edges.map((e) => [
		nodeIdMap.get(e.source)!,
		nodeIdMap.get(e.target)!,
	] as [number, number]);

	const adj = new Map<number, Set<number>>();
	for (const v of vertexSet) {
		adj.set(v, new Set());
	}
	for (const [u, v] of edgeList) {
		adj.get(u)?.add(v);
		adj.get(v)?.add(u);
	}

	// Check if distance hereditary (no isometric cycles of length >= 5)
	const isDH = isDistanceHereditary(adj, vertexSet);
	const actual = isDH ? "distance_hereditary" : "not_distance_hereditary";
	const valid = actual === expected;

	return {
		property: "DistanceHereditary",
		expected,
		actual,
		valid,
		message: valid
			? undefined
			: `Expected ${expected} but found ${actual}`,
	};
};
