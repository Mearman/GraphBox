/**
 * forbidden_subgraph Graph Class Analyzers
 *
 * AUTO-GENERATED by scripts/codegen/generate-graph-classes.ts
 * DO NOT EDIT MANUALLY
 */

import {
	buildAdjacencyList,
	hasInducedSubgraph,
	SUBGRAPH_PATTERNS
} from "../algorithms/extraction/forbidden-subgraphs.js";
import type {
	ATFree,
	BullFree,
	C5Free,
	DistanceHereditary,
	GemFree,
	HHFree,
	P5Free,
	WeaklyChordal
} from "../generation/spec/forbidden-subgraph.js";
import {
	hasAsteroidalTriple,
	hasInducedCycle as checkInducedCycle,
	isDistanceHereditary as checkDistanceHereditary
} from "../validation/forbidden-subgraph-helpers.js";
import type { AnalyzerGraph , ComputePolicy } from "./types.js";

/**
 * Convert AnalyzerGraph to adjacency list format.
 *
 * @param g - Analyzer graph
 * @returns Tuple of (vertexSet, edgeList)
 */
const toAdjacencyFormat = (g: AnalyzerGraph): [Set<number>, Array<[number, number]>] => {
	// Map vertex IDs to numbers
	const nodeIdMap = new Map<string, number>();
	for (const [index, v] of g.vertices.entries()) {
		nodeIdMap.set(v.id, index);
	}

	// Create vertex set and edge list
	const vertexSet = new Set<number>(g.vertices.map((_, index) => index));
	const edgeList: Array<[number, number]> = [];

	for (const edge of g.edges) {
		if (edge.endpoints.length === 2) {
			const [sourceId, tgtId] = edge.endpoints;
			const source = nodeIdMap.get(sourceId);
			const tgt = nodeIdMap.get(tgtId);
			if (source !== undefined && tgt !== undefined) {
				edgeList.push([source, tgt]);
			}
		}
	}

	return [vertexSet, edgeList];
};

/**
 * Build mutable adjacency map from AnalyzerGraph.
 *
 * @param g - Analyzer graph
 * @returns Adjacency map
 */
const buildAdjacencyMap = (g: AnalyzerGraph): Map<number, Set<number>> => {
	const [vertexSet, edgeList] = toAdjacencyFormat(g);
	const adj = new Map<number, Set<number>>();

	for (const v of vertexSet) {
		adj.set(v, new Set());
	}

	for (const [u, v] of edgeList) {
		adj.get(u)?.add(v);
		adj.get(v)?.add(u);
	}

	return adj;
};

/**
 * Compute P5Free property from graph structure.
 * Contains no induced path on 5 vertices
 * @param g
 * @param _policy
 */
export const computeP5Free = (
	g: AnalyzerGraph,
	_policy: ComputePolicy
): P5Free => {
	const [vertexSet, edgeList] = toAdjacencyFormat(g);
	const adjacency = buildAdjacencyList(vertexSet, edgeList);
	const hasP5 = hasInducedSubgraph(adjacency, SUBGRAPH_PATTERNS.P5);
	return hasP5 ? { kind: "has_p5" } : { kind: "p5_free" };
};

/**
 * Compute C5Free property from graph structure.
 * Contains no induced cycle on 5 vertices
 * @param g
 * @param _policy
 */
export const computeC5Free = (
	g: AnalyzerGraph,
	_policy: ComputePolicy
): C5Free => {
	const [vertexSet, edgeList] = toAdjacencyFormat(g);
	const adjacency = buildAdjacencyList(vertexSet, edgeList);
	const hasC5 = hasInducedSubgraph(adjacency, SUBGRAPH_PATTERNS.C5);
	return hasC5 ? { kind: "has_c5" } : { kind: "c5_free" };
};

/**
 * Compute BullFree property from graph structure.
 * Contains no induced bull graph
 * @param g
 * @param _policy
 */
export const computeBullFree = (
	g: AnalyzerGraph,
	_policy: ComputePolicy
): BullFree => {
	const [vertexSet, edgeList] = toAdjacencyFormat(g);
	const adjacency = buildAdjacencyList(vertexSet, edgeList);
	const hasBull = hasInducedSubgraph(adjacency, SUBGRAPH_PATTERNS.bull);
	return hasBull ? { kind: "has_bull" } : { kind: "bull_free" };
};

/**
 * Compute GemFree property from graph structure.
 * Contains no induced gem graph
 * @param g
 * @param _policy
 */
export const computeGemFree = (
	g: AnalyzerGraph,
	_policy: ComputePolicy
): GemFree => {
	const [vertexSet, edgeList] = toAdjacencyFormat(g);
	const adjacency = buildAdjacencyList(vertexSet, edgeList);
	const hasGem = hasInducedSubgraph(adjacency, SUBGRAPH_PATTERNS.gem);
	return hasGem ? { kind: "has_gem" } : { kind: "gem_free" };
};

/**
 * Compute ATFree property from graph structure.
 * No asteroidal triple of vertices
 * @param g
 * @param _policy
 */
export const computeATFree = (
	g: AnalyzerGraph,
	_policy: ComputePolicy
): ATFree => {
	const adj = buildAdjacencyMap(g);
	const vertices = [...adj.keys()];

	// Check all triples for asteroidal triples
	let hasAT = false;
	for (let index = 0; index < vertices.length && !hasAT; index++) {
		for (let index_ = index + 1; index_ < vertices.length && !hasAT; index_++) {
			for (let k = index_ + 1; k < vertices.length && !hasAT; k++) {
				if (hasAsteroidalTriple(adj, vertices[index], vertices[index_], vertices[k])) {
					hasAT = true;
				}
			}
		}
	}

	return hasAT ? { kind: "has_asteroidal_triple" } : { kind: "at_free" };
};

/**
 * Compute HHFree property from graph structure.
 * No induced house or hole (cycle of length >= 5)
 * @param g
 * @param _policy
 */
export const computeHHFree = (
	g: AnalyzerGraph,
	_policy: ComputePolicy
): HHFree => {
	const [vertexSet, edgeList] = toAdjacencyFormat(g);
	const adjacency = buildAdjacencyList(vertexSet, edgeList);
	const adj = buildAdjacencyMap(g);

	// Early exit: graph too sparse for cycles (need at least 5 edges for a 5-cycle)
	if (edgeList.length < 5) {
		// Still need to check for house pattern (5 vertices, 6 edges)
		const hasHouse = hasInducedSubgraph(adjacency, SUBGRAPH_PATTERNS.house);
		return hasHouse ? { kind: "has_house_or_hole" } : { kind: "hh_free" };
	}

	// Check for house
	const hasHouse = hasInducedSubgraph(adjacency, SUBGRAPH_PATTERNS.house);

	// Check for holes (cycles of length >= 5)
	let hasHole = false;
	for (let cycleLength = 5; cycleLength <= g.vertices.length; cycleLength++) {
		if (checkInducedCycle(adj, vertexSet, cycleLength)) {
			hasHole = true;
			break;
		}
	}

	return hasHouse || hasHole ? { kind: "has_house_or_hole" } : { kind: "hh_free" };
};

/**
 * Compute DistanceHereditary property from graph structure.
 * Distances preserved in all connected induced subgraphs
 * @param g
 * @param _policy
 */
export const computeDistanceHereditary = (
	g: AnalyzerGraph,
	_policy: ComputePolicy
): DistanceHereditary => {
	const adj = buildAdjacencyMap(g);
	const vertexSet = new Set(g.vertices.map((_, index) => index));

	// Early exit: graph too sparse for isometric cycles (need at least 5 edges)
	let edgeCount = 0;
	for (const neighbors of adj.values()) {
		edgeCount += neighbors.size;
	}
	edgeCount = edgeCount / 2; // Each edge counted twice

	if (edgeCount < 5) {
		return { kind: "distance_hereditary" };
	}

	const isDH = checkDistanceHereditary(adj, vertexSet);
	return isDH ? { kind: "distance_hereditary" } : { kind: "not_distance_hereditary" };
};

/**
 * Compute WeaklyChordal property from graph structure.
 * No induced hole or anti-hole of length >= 5
 * @param g
 * @param _policy
 */
export const computeWeaklyChordal = (
	g: AnalyzerGraph,
	_policy: ComputePolicy
): WeaklyChordal => {
	const [vertexSet] = toAdjacencyFormat(g);
	const adj = buildAdjacencyMap(g);

	// Early exit: graph too sparse for holes (need at least 5 edges)
	let edgeCount = 0;
	for (const neighbors of adj.values()) {
		edgeCount += neighbors.size;
	}
	edgeCount = edgeCount / 2; // Each edge counted twice

	if (edgeCount < 5 && // Still need to check complement for antiholes
		// But complement of sparse graph is dense, so skip antihole check for very sparse graphs
		// A graph with < 5 edges has complement with > C(n,2) - 5 edges
		// For n >= 5, complement is dense enough that we should check
		g.vertices.length < 5) {
		return { kind: "weakly_chordal" };
	}

	// Check for holes (cycles of length >= 5)
	let hasHole = false;
	for (let cycleLength = 5; cycleLength <= g.vertices.length; cycleLength++) {
		if (checkInducedCycle(adj, vertexSet, cycleLength)) {
			hasHole = true;
			break;
		}
	}

	// Check for antiholes (complement has hole)
	// Build complement adjacency
	const complementAdj = new Map<number, Set<number>>();
	for (const v of vertexSet) {
		complementAdj.set(v, new Set());
	}

	const vertices = [...vertexSet];
	for (let index = 0; index < vertices.length; index++) {
		for (let index_ = index + 1; index_ < vertices.length; index_++) {
			const u = vertices[index];
			const v = vertices[index_];
			// Add edge in complement if not adjacent in original
			if (!adj.get(u)?.has(v)) {
				complementAdj.get(u)?.add(v);
				complementAdj.get(v)?.add(u);
			}
		}
	}

	let hasAntihole = false;
	for (let cycleLength = 5; cycleLength <= g.vertices.length; cycleLength++) {
		if (checkInducedCycle(complementAdj, vertexSet, cycleLength)) {
			hasAntihole = true;
			break;
		}
	}

	return hasHole || hasAntihole ? { kind: "has_hole_or_antihole" } : { kind: "weakly_chordal" };
};
