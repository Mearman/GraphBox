/**
 * perfect_variants Graph Class Analyzers
 *
 * AUTO-GENERATED by scripts/codegen/generate-graph-classes.ts
 * DO NOT EDIT MANUALLY - But TODOs have been implemented
 */

import {
	type AdjacencyList,
	buildAdjacencyList,
	hasInducedSubgraph,
	SUBGRAPH_PATTERNS} from "../algorithms/extraction/forbidden-subgraphs.js";
import type {
	Modular,
	Ptolemaic,
	QuasiLine
} from "../generation/spec/perfect-variants";
import { isDistanceHereditary } from "../validation/forbidden-subgraph-helpers.js";
import type { AnalyzerGraph , ComputePolicy } from "./types.js";
import { isChordalUndirectedBinary } from "./types.js";

/**
 * Convert AnalyzerGraph to adjacency format for forbidden subgraph detection.
 *
 * @param g - Analyzer graph
 * @returns Tuple of (vertexSet, edgeList)
 */
const toAdjacencyFormat = (g: AnalyzerGraph): [Set<number>, Array<[number, number]>] => {
	const nodeIdMap = new Map<string, number>();
	for (const [index, v] of g.vertices.entries()) {
		nodeIdMap.set(v.id, index);
	}

	const vertexSet = new Set<number>(g.vertices.map((_, index) => index));
	const edgeList: Array<[number, number]> = [];

	for (const edge of g.edges) {
		if (edge.endpoints.length === 2 && !edge.directed) {
			const [sourceId, targetId] = edge.endpoints;
			const source = nodeIdMap.get(sourceId);
			const target = nodeIdMap.get(targetId);
			if (source !== undefined && target !== undefined) {
				edgeList.push([source, target]);
			}
		}
	}

	return [vertexSet, edgeList];
};

/**
 * Compute complement graph adjacency list.
 * In the complement, edges exist between vertices that are NOT adjacent in the original.
 *
 * @param adj - Original adjacency list
 * @param vertices - Set of all vertices
 * @returns Complement adjacency list
 */
const computeComplement = (
	adj: AdjacencyList,
	vertices: Set<number>
): AdjacencyList => {
	const complement = new Map<number, Set<number>>();

	for (const v of vertices) {
		const neighbors = new Set<number>();
		for (const u of vertices) {
			if (u !== v && !adj.get(v)?.has(u)) {
				neighbors.add(u);
			}
		}
		complement.set(v, neighbors);
	}

	return complement;
};

/**
 * Find all non-trivial modules in the graph.
 * A module is a set of vertices with identical external neighborhoods.
 * Twins are vertices in the same module.
 *
 * @param g - Analyzer graph
 * @returns True if any non-trivial modules exist
 */
const hasNonTrivialModules = (g: AnalyzerGraph): boolean => {
	const n = g.vertices.length;

	// Trivial graphs are modular
	if (n <= 2) return false;

	// Build adjacency map
	const adj = new Map<string, Set<string>>();
	for (const v of g.vertices) {
		adj.set(v.id, new Set());
	}

	for (const edge of g.edges) {
		if (edge.endpoints.length === 2 && !edge.directed) {
			const [u, v] = edge.endpoints;
			adj.get(u)?.add(v);
			adj.get(v)?.add(u);
		}
	}

	// Check each pair for twin relationship
	// Twins have identical external neighborhoods (neighbors excluding both u and v)
	for (let index = 0; index < n; index++) {
		for (let index_ = index + 1; index_ < n; index_++) {
			const u = g.vertices[index].id;
			const v = g.vertices[index_].id;

			const neighborsU = adj.get(u);
			const neighborsV = adj.get(v);

			if (!neighborsU || !neighborsV) continue;

			// External neighbors: exclude both u and v
			const externalU = new Set([...neighborsU].filter(w => w !== v && w !== u));
			const externalV = new Set([...neighborsV].filter(w => w !== u && w !== v));

			if (externalU.size === externalV.size) {
				let identical = true;
				for (const w of externalU) {
					if (!externalV.has(w)) {
						identical = false;
						break;
					}
				}

				if (identical && (neighborsU.has(v) === neighborsV.has(u))) {
					// Found twins with identical external neighborhoods
					// Also check adjacency relationship is symmetric
					return true;
				}
			}
		}
	}

	return false;
};

/**
 * Compute Modular property from graph structure.
 * Every module is trivial (no twin vertices with identical neighborhoods)
 *
 * A modular graph has no non-trivial modules. Two vertices form a module if they
 * have identical external neighborhoods.
 *
 * For small graphs (n <= 10): Exhaustive pairwise comparison
 * For large graphs: Heuristic twin-finding (may return unconstrained for complex cases)
 *
 * @param g - Analyzer graph
 * @param _policy - Computation policy (unused)
 * @returns Modular property: "modular", "not_modular", or "unconstrained"
 */
export const computeModular = (
	g: AnalyzerGraph,
	_policy?: ComputePolicy
): Modular => {
	// Trivial cases
	if (g.vertices.length === 0) return { kind: "modular" };
	if (g.vertices.length === 1) return { kind: "modular" };

	// Skip directed graphs
	if (g.edges.some(e => e.directed)) {
		return { kind: "unconstrained" };
	}

	// For large graphs, use heuristic
	if (g.vertices.length > 30) {
		// Heuristic: Check degree sequence
		// If all vertices have different degrees, no twins can exist
		const degrees = new Map<string, number>();
		for (const v of g.vertices) {
			degrees.set(v.id, 0);
		}

		for (const edge of g.edges) {
			if (edge.endpoints.length === 2) {
				const [u, v] = edge.endpoints;
				degrees.set(u, (degrees.get(u) ?? 0) + 1);
				degrees.set(v, (degrees.get(v) ?? 0) + 1);
			}
		}

		const degreeList = [...degrees.values()].sort((a, b) => a - b);
		const uniqueDegrees = new Set(degreeList);

		if (uniqueDegrees.size === degreeList.length) {
			// All degrees distinct => no twins => modular
			return { kind: "modular" };
		}

		// Otherwise, uncertain for large graphs
		return { kind: "unconstrained" };
	}

	// Exhaustive check for small graphs
	const hasModules = hasNonTrivialModules(g);
	return hasModules ? { kind: "not_modular" } : { kind: "modular" };
};

/**
 * Compute Ptolemaic property from graph structure.
 * Ptolemaic graphs are both distance-hereditary AND chordal.
 *
 * A graph is Ptolemaic if and only if it satisfies both:
 * 1. Distance-hereditary: No induced house, hole, domino, or gem
 * 2. Chordal: No induced cycle of length >= 4
 *
 * Equivalently: Ptolemaic = chordal + distance-hereditary
 *
 * @param g - Analyzer graph
 * @param _policy - Computation policy (unused)
 * @returns Ptolemaic property: "ptolemaic" or "not_ptolemaic"
 */
export const computePtolemaic = (
	g: AnalyzerGraph,
	_policy?: ComputePolicy
): Ptolemaic => {
	// Trivial cases
	if (g.vertices.length === 0) return { kind: "ptolemaic" };
	if (g.vertices.length === 1) return { kind: "ptolemaic" };

	// Skip directed graphs
	if (g.edges.some(e => e.directed)) {
		return { kind: "unconstrained" };
	}

	// Check chordal property
	const isChordal = isChordalUndirectedBinary(g);
	if (!isChordal) {
		return { kind: "not_ptolemaic" };
	}

	// Check distance-hereditary property
	const [vertexSet, edgeList] = toAdjacencyFormat(g);
	const adj = buildAdjacencyList(vertexSet, edgeList);
	const isDistributionHered = isDistanceHereditary(adj as Map<number, Set<number>>, vertexSet);

	if (!isDistributionHered) {
		return { kind: "not_ptolemaic" };
	}

	// Both conditions satisfied
	return { kind: "ptolemaic" };
};

/**
 * Compute QuasiLine property from graph structure.
 * Quasi-line graphs have no induced gem and no induced co-gem.
 *
 * A gem is a graph with 5 vertices: P4 (path of length 4) plus a universal vertex
 * connected to all vertices of the P4. The co-gem is the complement of the gem.
 *
 * Detection strategy:
 * 1. Check for induced gem
 * 2. Check for induced co-gem (gem in complement graph)
 *
 * @param g - Analyzer graph
 * @param _policy - Computation policy (unused)
 * @returns QuasiLine property: "quasi_line" or "not_quasi_line"
 */
export const computeQuasiLine = (
	g: AnalyzerGraph,
	_policy?: ComputePolicy
): QuasiLine => {
	// Skip directed graphs
	if (g.edges.some(e => e.directed)) {
		return { kind: "unconstrained" };
	}

	// Trivial cases
	if (g.vertices.length < 5) return { kind: "quasi_line" };

	// Convert to adjacency format
	const [vertexSet, edgeList] = toAdjacencyFormat(g);
	const adj = buildAdjacencyList(vertexSet, edgeList);

	// Check for induced gem
	const hasGem = hasInducedSubgraph(adj, SUBGRAPH_PATTERNS.gem);
	if (hasGem) {
		return { kind: "not_quasi_line" };
	}

	// Check for induced co-gem (gem in complement)
	const complementAdj = computeComplement(adj, vertexSet);
	const hasCoGem = hasInducedSubgraph(complementAdj, SUBGRAPH_PATTERNS.gem);
	if (hasCoGem) {
		return { kind: "not_quasi_line" };
	}

	return { kind: "quasi_line" };
};
