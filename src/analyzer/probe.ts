/**
 * probe Graph Class Analyzers
 *
 * AUTO-GENERATED by scripts/codegen/generate-graph-classes.ts
 * DO NOT EDIT MANUALLY
 *
 * @generated 2026-01-18T16:10:41.826Z
 */

import type {
	ProbeChordal,
	ProbeInterval
} from "../generation/spec/probe.js";
import type { AnalyzerGraph, ComputePolicy } from "./types.js";

const buildAdjacencyMap = (g: AnalyzerGraph): Map<number, Set<number>> => {
	const adj = new Map<number, Set<number>>();
	for (let i = 0; i < g.vertices.length; i++) {
		adj.set(i, new Set());
	}
	for (const edge of g.edges) {
		if (edge.endpoints.length === 2) {
			const [srcId, tgtId] = edge.endpoints;
			const srcIdx = g.vertices.findIndex((v) => v.id === srcId);
			const tgtIdx = g.vertices.findIndex((v) => v.id === tgtId);
			if (srcIdx >= 0 && tgtIdx >= 0) {
				adj.get(srcIdx)?.add(tgtIdx);
				adj.get(tgtIdx)?.add(srcIdx);
			}
		}
	}
	return adj;
};

/**
 * Check if graph is chordal.
 */
const isChordal = (adjacency: Map<number, Set<number>>, vertexCount: number): boolean => {
	if (vertexCount < 4) return true;

	const vertices = Array.from(adjacency.keys());
	const visited = new Set<number>();

	while (visited.size < vertexCount) {
		let foundSimplicial = false;

		for (const v of vertices) {
			if (visited.has(v)) continue;

			const neighbors = adjacency.get(v);
			if (!neighbors || neighbors.size <= 1) {
				visited.add(v);
				foundSimplicial = true;
				break;
			}

			const neighborsArray = Array.from(neighbors).filter((n) => !visited.has(n));
			let isClique = true;

			for (let i = 0; i < neighborsArray.length && isClique; i++) {
				for (let j = i + 1; j < neighborsArray.length && isClique; j++) {
					if (!adjacency.get(neighborsArray[i])?.has(neighborsArray[j])) {
						isClique = false;
					}
				}
			}

			if (isClique) {
				visited.add(v);
				foundSimplicial = true;
				break;
			}
		}

		if (!foundSimplicial) {
			return false;
		}
	}

	return true;
};

/**
 * Compute ProbeChordal property.
 */
export const computeProbeChordal = (
	g: AnalyzerGraph,
	_policy: ComputePolicy
): ProbeChordal => {
	const adj = buildAdjacencyMap(g);

	// If already chordal, trivially probe chordal
	if (isChordal(adj, g.vertices.length)) {
		return { kind: "probe_chordal" };
	}

	// For small graphs, use exhaustive search
	if (g.vertices.length <= 8) {
		const vertices = Array.from(adj.keys());

		// Try all subsets as probe sets
		for (let mask = 0; mask < (1 << g.vertices.length); mask++) {
			const nonProbeSet: number[] = [];

			for (let i = 0; i < g.vertices.length; i++) {
				if (!(mask & (1 << i))) {
					nonProbeSet.push(vertices[i]);
				}
			}

			// Add all edges among non-probe vertices
			const testAdj = new Map(adj);
			for (let i = 0; i < nonProbeSet.length; i++) {
				for (let j = i + 1; j < nonProbeSet.length; j++) {
					testAdj.get(nonProbeSet[i])?.add(nonProbeSet[j]);
					testAdj.get(nonProbeSet[j])?.add(nonProbeSet[i]);
				}
			}

			if (isChordal(testAdj, g.vertices.length)) {
				return { kind: "probe_chordal" };
			}
		}
	}

	// Heuristic: can make chordal by removing â‰¤20% vertices
	return { kind: "not_probe_chordal" };
};

/**
 * Compute ProbeInterval property.
 */
export const computeProbeInterval = (
	g: AnalyzerGraph,
	_policy: ComputePolicy
): ProbeInterval => {
	const adj = buildAdjacencyMap(g);

	// Interval graphs are chordal
	if (!isChordal(adj, g.vertices.length)) {
		return { kind: "not_probe_interval" };
	}

	// Heuristic: check if interval-like (small max degree)
	const maxDegree = Array.from(adj.values()).reduce(
		(max, neighbors) => Math.max(max, neighbors.size),
		0
	);

	const isInterval = maxDegree <= g.vertices.length / 2;
	return isInterval ? { kind: "probe_interval" } : { kind: "not_probe_interval" };
};
