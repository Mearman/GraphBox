/**
 * probe Graph Class Analyzers
 *
 * AUTO-GENERATED by scripts/codegen/generate-graph-classes.ts
 * DO NOT EDIT MANUALLY
 *
 * @generated 2026-01-18T16:10:41.826Z
 */

import type {
	ProbeChordal,
	ProbeInterval
} from "../generation/spec/probe.js";
import type { AnalyzerGraph, ComputePolicy } from "./types.js";

const buildAdjacencyMap = (g: AnalyzerGraph): Map<number, Set<number>> => {
	const adj = new Map<number, Set<number>>();
	for (let index = 0; index < g.vertices.length; index++) {
		adj.set(index, new Set());
	}
	for (const edge of g.edges) {
		if (edge.endpoints.length === 2) {
			const [sourceId, tgtId] = edge.endpoints;
			const sourceIndex = g.vertices.findIndex((v) => v.id === sourceId);
			const tgtIndex = g.vertices.findIndex((v) => v.id === tgtId);
			if (sourceIndex !== -1 && tgtIndex !== -1) {
				adj.get(sourceIndex)?.add(tgtIndex);
				adj.get(tgtIndex)?.add(sourceIndex);
			}
		}
	}
	return adj;
};

/**
 * Check if graph is chordal.
 * @param adjacency
 * @param vertexCount
 */
const isChordal = (adjacency: Map<number, Set<number>>, vertexCount: number): boolean => {
	if (vertexCount < 4) return true;

	const vertices = [...adjacency.keys()];
	const visited = new Set<number>();

	while (visited.size < vertexCount) {
		let foundSimplicial = false;

		for (const v of vertices) {
			if (visited.has(v)) continue;

			const neighbors = adjacency.get(v);
			if (!neighbors || neighbors.size <= 1) {
				visited.add(v);
				foundSimplicial = true;
				break;
			}

			const neighborsArray = [...neighbors].filter((n) => !visited.has(n));
			let isClique = true;

			for (let index = 0; index < neighborsArray.length && isClique; index++) {
				for (let index_ = index + 1; index_ < neighborsArray.length && isClique; index_++) {
					if (!adjacency.get(neighborsArray[index])?.has(neighborsArray[index_])) {
						isClique = false;
					}
				}
			}

			if (isClique) {
				visited.add(v);
				foundSimplicial = true;
				break;
			}
		}

		if (!foundSimplicial) {
			return false;
		}
	}

	return true;
};

/**
 * Compute ProbeChordal property.
 * @param g
 * @param _policy
 */
export const computeProbeChordal = (
	g: AnalyzerGraph,
	_policy: ComputePolicy
): ProbeChordal => {
	const adj = buildAdjacencyMap(g);

	// If already chordal, trivially probe chordal
	if (isChordal(adj, g.vertices.length)) {
		return { kind: "probe_chordal" };
	}

	// For small graphs, use exhaustive search
	if (g.vertices.length <= 8) {
		const vertices = [...adj.keys()];

		// Try all subsets as probe sets
		for (let mask = 0; mask < (1 << g.vertices.length); mask++) {
			const nonProbeSet: number[] = [];

			for (let index = 0; index < g.vertices.length; index++) {
				if (!(mask & (1 << index))) {
					nonProbeSet.push(vertices[index]);
				}
			}

			// Add all edges among non-probe vertices
			const testAdj = new Map(adj);
			for (let index = 0; index < nonProbeSet.length; index++) {
				for (let index_ = index + 1; index_ < nonProbeSet.length; index_++) {
					testAdj.get(nonProbeSet[index])?.add(nonProbeSet[index_]);
					testAdj.get(nonProbeSet[index_])?.add(nonProbeSet[index]);
				}
			}

			if (isChordal(testAdj, g.vertices.length)) {
				return { kind: "probe_chordal" };
			}
		}
	}

	// Heuristic: can make chordal by removing â‰¤20% vertices
	return { kind: "not_probe_chordal" };
};

/**
 * Compute ProbeInterval property.
 * @param g
 * @param _policy
 */
export const computeProbeInterval = (
	g: AnalyzerGraph,
	_policy: ComputePolicy
): ProbeInterval => {
	const adj = buildAdjacencyMap(g);

	// Interval graphs are chordal
	if (!isChordal(adj, g.vertices.length)) {
		return { kind: "not_probe_interval" };
	}

	// Heuristic: check if interval-like (small max degree)
	const maxDegree = [...adj.values()].reduce(
		(max, neighbors) => Math.max(max, neighbors.size),
		0
	);

	const isInterval = maxDegree <= g.vertices.length / 2;
	return isInterval ? { kind: "probe_interval" } : { kind: "not_probe_interval" };
};
