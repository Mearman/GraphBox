/**
 * intersection Graph Class Analyzers
 *
 * AUTO-GENERATED by scripts/codegen/generate-graph-classes.ts
 * DO NOT EDIT MANUALLY
 *
 * @generated 2026-01-18T16:10:41.826Z
 */

import type {
	CircularArc,
	ProperCircularArc
} from "../generation/spec/intersection.js";
import type { AnalyzerGraph, ComputePolicy } from "./types.js";

/**
 * Convert AnalyzerGraph to adjacency map format.
 * @param g
 */
const buildAdjacencyMap = (g: AnalyzerGraph): Map<number, Set<number>> => {
	const adj = new Map<number, Set<number>>();

	// Initialize all vertices
	for (let index = 0; index < g.vertices.length; index++) {
		adj.set(index, new Set());
	}

	// Add edges
	for (const edge of g.edges) {
		if (edge.endpoints.length === 2) {
			const [sourceId, tgtId] = edge.endpoints;
			const sourceIndex = g.vertices.findIndex((v) => v.id === sourceId);
			const tgtIndex = g.vertices.findIndex((v) => v.id === tgtId);

			if (sourceIndex !== -1 && tgtIndex !== -1) {
				adj.get(sourceIndex)?.add(tgtIndex);
				adj.get(tgtIndex)?.add(sourceIndex);
			}
		}
	}

	return adj;
};

/**
 * Check if graph can be represented as circular arc intersection model.
 * @param adjacency
 * @param vertexCount
 */
const isCircularArcGraph = (
	adjacency: Map<number, Set<number>>,
	vertexCount: number
): boolean => {
	if (vertexCount <= 4) {
		return true;
	}

	const vertices = [...adjacency.keys()];
	const maxAttempts = Math.min(50, vertexCount * 2);

	for (let attempt = 0; attempt < maxAttempts; attempt++) {
		const ordering = [...vertices].sort(() => Math.random() - 0.5); // eslint-disable-line unicorn/no-array-sort -- intentional shuffle

		if (isValidCircularArcOrdering(adjacency, ordering)) {
			return true;
		}
	}

	if (isValidCircularArcOrdering(adjacency, vertices)) {
		return true;
	}

	return false;
};

/**
 * Check if given vertex ordering is a valid circular arc model.
 * @param adjacency
 * @param ordering
 */
const isValidCircularArcOrdering = (
	adjacency: Map<number, Set<number>>,
	ordering: number[]
): boolean => {
	const n = ordering.length;
	const position = new Map<number, number>();
	for (let index = 0; index < n; index++) {
		position.set(ordering[index], index);
	}

	for (const v of ordering) {
		const neighbors = adjacency.get(v);
		if (!neighbors || neighbors.size === 0) {
			continue;
		}

		const neighborPositions = [...neighbors]
			.map((nb) => position.get(nb))
			.filter((p): p is number => p !== undefined)
			.sort((a, b) => a - b);

		if (neighborPositions.length === 0) {
			continue;
		}

		let consecutive = true;
		for (let index = 1; index < neighborPositions.length; index++) {
			if (neighborPositions[index] - neighborPositions[index - 1] !== 1) {
				consecutive = false;
				break;
			}
		}

		if (consecutive) {
			continue;
		}

		const maxPos = neighborPositions.at(-1);
		const minPos = neighborPositions[0];

		consecutive = true;
		for (let index = 1; index < neighborPositions.length; index++) {
			const diff = neighborPositions[index] - neighborPositions[index - 1];
			if (diff !== 1 && !(neighborPositions[index] === maxPos && neighborPositions[index - 1] === minPos)) {
				consecutive = false;
				break;
			}
		}

		if (!consecutive) {
			return false;
		}
	}

	return true;
};

/**
 * Check if a circular arc model is proper (no arc contains another).
 * @param adjacency
 * @param vertexCount
 */
const isProperCircularArcGraph = (
	adjacency: Map<number, Set<number>>,
	vertexCount: number
): boolean => {
	if (!isCircularArcGraph(adjacency, vertexCount)) {
		return false;
	}

	// Proper circular arc graphs = claw-free circular arc graphs
	const vertices = [...adjacency.keys()];

	for (const v of vertices) {
		const neighborsSet = adjacency.get(v);
		if (!neighborsSet) continue;

		const neighbors: number[] = [...neighborsSet];

		for (let index = 0; index < neighbors.length; index++) {
			for (let index_ = index + 1; index_ < neighbors.length; index_++) {
				for (let k = index_ + 1; k < neighbors.length; k++) {
					const n1: number = neighbors[index];
					const n2: number = neighbors[index_];
					const n3: number = neighbors[k];

					const n1Neighbors = adjacency.get(n1);
					const n2Neighbors = adjacency.get(n2);
					const n3Neighbors = adjacency.get(n3);

					if (!n1Neighbors || !n2Neighbors || !n3Neighbors) {
						continue;
					}

					const n1n2Connected = n1Neighbors.has(n2);
					const n1n3Connected = n1Neighbors.has(n3);
					const n2n3Connected = n2Neighbors.has(n3);

					if (!n1n2Connected && !n1n3Connected && !n2n3Connected) {
						return false;
					}
				}
			}
		}
	}

	return true;
};

/**
 * Compute CircularArc property from graph structure.
 * Intersection graph of arcs on a circle
 * @param g
 * @param _policy
 */
export const computeCircularArc = (
	g: AnalyzerGraph,
	_policy: ComputePolicy
): CircularArc => {
	const adj = buildAdjacencyMap(g);
	const isCA = isCircularArcGraph(adj, g.vertices.length);
	return isCA ? { kind: "circular_arc" } : { kind: "not_circular_arc" };
};

/**
 * Compute ProperCircularArc property from graph structure.
 * Circular arc graph with no arc containment
 * @param g
 * @param _policy
 */
export const computeProperCircularArc = (
	g: AnalyzerGraph,
	_policy: ComputePolicy
): ProperCircularArc => {
	const adj = buildAdjacencyMap(g);
	const isPCA = isProperCircularArcGraph(adj, g.vertices.length);
	return isPCA ? { kind: "proper_circular_arc" } : { kind: "not_proper_circular_arc" };
};
