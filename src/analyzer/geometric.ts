/**
 * geometric Graph Class Analyzers
 *
 * AUTO-GENERATED by scripts/codegen/generate-graph-classes.ts
 * DO NOT EDIT MANUALLY - But TODOs have been implemented
 */

import {
	buildAdjacencyList,
	hasInducedSubgraph,
	SUBGRAPH_PATTERNS
} from "../algorithms/extraction/forbidden-subgraphs.js";
import type {
	Planar
} from "../generation/spec/geometric.js";
import type { AnalyzerGraph , ComputePolicy } from "./types.js";

/**
 * Convert AnalyzerGraph to adjacency format for subgraph detection.
 * @param g
 */
const toAdjacencyFormat = (g: AnalyzerGraph): [Set<number>, Array<[number, number]>] => {
	const nodeIdMap = new Map<string, number>();
	for (const [index, v] of g.vertices.entries()) {
		nodeIdMap.set(v.id, index);
	}

	const vertexSet = new Set<number>(g.vertices.map((_, index) => index));
	const edgeList: Array<[number, number]> = [];

	for (const edge of g.edges) {
		if (edge.endpoints.length === 2 && !edge.directed) {
			const [sourceId, targetId] = edge.endpoints;
			const source = nodeIdMap.get(sourceId);
			const target = nodeIdMap.get(targetId);
			if (source !== undefined && target !== undefined && source !== target) {
				edgeList.push([source, target]);
			}
		}
	}

	return [vertexSet, edgeList];
};

/**
 * Check if graph contains K5 (complete graph on 5 vertices) as a subgraph.
 * @param g
 */
const hasK5 = (g: AnalyzerGraph): boolean => {
	const [vertexSet, edgeList] = toAdjacencyFormat(g);
	const adj = buildAdjacencyList(vertexSet, edgeList);
	return hasInducedSubgraph(adj, SUBGRAPH_PATTERNS.K5);
};

/**
 * Check if graph contains K3,3 (complete bipartite graph with 3 vertices per partition).
 *
 * K3,3 is the utility graph: 3 houses {0,1,2} and 3 utilities {3,4,5}.
 * Each house connects to all utilities, no edges within partitions.
 * @param g
 */
const hasK33 = (g: AnalyzerGraph): boolean => {
	const n = g.vertices.length;
	if (n < 6) return false;

	const [vertexSet, edgeList] = toAdjacencyFormat(g);
	const adj = buildAdjacencyList(vertexSet, edgeList);

	// K3,3 pattern: 6 vertices, 9 edges
	// Vertices {0,1,2} all connect to {3,4,5}
	const k33Pattern = {
		name: "K3_3",
		size: 6,
		edges: [
			[0, 3], [0, 4], [0, 5],
			[1, 3], [1, 4], [1, 5],
			[2, 3], [2, 4], [2, 5],
		] as Array<[number, number]>,
	};

	return hasInducedSubgraph(adj, k33Pattern);
};

/**
 * Extended K5 detection for larger graphs (up to 20 vertices).
 * Uses a more exhaustive search by checking all 5-vertex combinations.
 * @param g
 */
const hasK5Extended = (g: AnalyzerGraph): boolean => {
	const n = g.vertices.length;
	if (n < 5) return false;

	const [vertexSet, edgeList] = toAdjacencyFormat(g);
	const adj = buildAdjacencyList(vertexSet, edgeList);

	// For each 5-vertex combination, check if it forms K5
	const vertices = [...vertexSet];
	if (vertices.length < 5) return false;

	// Check all combinations of 5 vertices
	for (let index = 0; index < vertices.length - 4; index++) {
		for (let index_ = index + 1; index_ < vertices.length - 3; index_++) {
			for (let k = index_ + 1; k < vertices.length - 2; k++) {
				for (let l = k + 1; l < vertices.length - 1; l++) {
					for (let m = l + 1; m < vertices.length; m++) {
						const subset = new Set([vertices[index], vertices[index_], vertices[k], vertices[l], vertices[m]]);
						if (isCompleteGraph(adj, subset)) {
							return true;
						}
					}
				}
			}
		}
	}

	return false;
};

/**
 * Extended K3,3 detection for larger graphs (up to 20 vertices).
 * Uses a more exhaustive search by checking different bipartitions.
 * @param g
 */
const hasK33Extended = (g: AnalyzerGraph): boolean => {
	const n = g.vertices.length;
	if (n < 6) return false;

	const [vertexSet, edgeList] = toAdjacencyFormat(g);
	const adj = buildAdjacencyList(vertexSet, edgeList);
	const vertices = [...vertexSet];

	// Try all possible 6-vertex combinations and bipartitions
	for (let index = 0; index < vertices.length - 5; index++) {
		for (let index_ = index + 1; index_ < vertices.length - 4; index_++) {
			for (let k = index_ + 1; k < vertices.length - 3; k++) {
				for (let l = k + 1; l < vertices.length - 2; l++) {
					for (let m = l + 1; m < vertices.length - 1; m++) {
						for (let n = m + 1; n < vertices.length; n++) {
							const sixVertices = [vertices[index], vertices[index_], vertices[k], vertices[l], vertices[m], vertices[n]];

							// Try all ways to split 6 vertices into two groups of 3
							// There are C(6,3)/2 = 10 unique bipartitions
							const bipartitions = [
								[[0,1,2], [3,4,5]],
								[[0,1,3], [2,4,5]],
								[[0,1,4], [2,3,5]],
								[[0,1,5], [2,3,4]],
								[[0,2,3], [1,4,5]],
								[[0,2,4], [1,3,5]],
								[[0,2,5], [1,3,4]],
								[[0,3,4], [1,2,5]],
								[[0,3,5], [1,2,4]],
								[[0,4,5], [1,2,3]],
							] as Array<[Array<number>, Array<number>]>;

							for (const [part1, part2] of bipartitions) {
								if (isCompleteBipartite(adj, sixVertices, part1, part2)) {
									return true;
								}
							}
						}
					}
				}
			}
		}
	}

	return false;
};

/**
 * Check if a subset of vertices forms a complete graph.
 * @param adj
 * @param vertices
 */
const isCompleteGraph = (
	adj: ReadonlyMap<number, ReadonlySet<number>>,
	vertices: Set<number>
): boolean => {
	const vertArray = [...vertices];
	for (let index = 0; index < vertArray.length; index++) {
		for (let index_ = index + 1; index_ < vertArray.length; index_++) {
			const neighbors = adj.get(vertArray[index]) ?? new Set();
			if (!neighbors.has(vertArray[index_])) {
				return false;
			}
		}
	}
	return true;
};

/**
 * Check if vertices form a complete bipartite graph K3,3.
 * @param adj
 * @param vertices
 * @param part1
 * @param part2
 */
const isCompleteBipartite = (
	adj: ReadonlyMap<number, ReadonlySet<number>>,
	vertices: number[],
	part1: number[],
	part2: number[]
): boolean => {
	// Check all edges between partitions exist
	for (const index of part1) {
		for (const index_ of part2) {
			const neighbors = adj.get(vertices[index]) ?? new Set();
			if (!neighbors.has(vertices[index_])) {
				return false;
			}
		}
	}

	// Check no edges within partitions
	for (const index of part1) {
		const neighbors = adj.get(vertices[index]) ?? new Set();
		for (const index_ of part1) {
			if (index !== index_ && neighbors.has(vertices[index_])) {
				return false;
			}
		}
	}

	for (const index of part2) {
		const neighbors = adj.get(vertices[index]) ?? new Set();
		for (const index_ of part2) {
			if (index !== index_ && neighbors.has(vertices[index_])) {
				return false;
			}
		}
	}

	return true;
};

/**
 * Compute Planar property from graph structure.
 * A graph is planar if it can be drawn in the plane without edge crossings.
 *
 * Uses Kuratowski's theorem: A graph is planar iff it contains no subdivision
 * of K5 or K3,3 (complete graph on 5 vertices or complete bipartite 3,3).
 *
 * Detection strategy:
 * 1. Trivial cases (n < 5): Always planar
 * 2. Edge count heuristic: If m > 3n - 6, then nonplanar (necessary condition)
 * 3. For small graphs (n <= 10): Check for K5 and K3,3 subgraphs
 * 4. For large graphs: Return unconstrained if heuristic passes
 *
 * @param g - Analyzer graph
 * @param _policy - Computation policy (unused)
 * @returns Planar property: "planar", "nonplanar", or "unconstrained"
 */
export const computePlanar = (
	g: AnalyzerGraph,
	_policy?: ComputePolicy
): Planar => {
	// Skip directed graphs
	if (g.edges.some(e => e.directed)) {
		return { kind: "unconstrained" };
	}

	const n = g.vertices.length;

	// Trivial cases
	if (n === 0) return { kind: "planar" };
	if (n === 1) return { kind: "planar" };
	if (n === 2) return { kind: "planar" };
	if (n === 3) return { kind: "planar" };
	if (n === 4) return { kind: "planar" };

	// Count undirected binary edges (excluding self-loops)
	let m = 0;
	for (const edge of g.edges) {
		if (edge.endpoints.length === 2 && !edge.directed) {
			const [u, v] = edge.endpoints;
			if (u !== v) {
				m++;
			}
		}
	}

	// Edge count heuristic: For planar graphs, m <= 3n - 6 (for n >= 3)
	// If m > 3n - 6, the graph is definitely nonplanar
	const maxEdges = 3 * n - 6;
	if (m > maxEdges) {
		return { kind: "nonplanar" };
	}

	// For small graphs (n <= 10), check for forbidden subgraphs K5 and K3,3
	if (n <= 10) {
		// Check for K5 (complete graph on 5 vertices)
		if (hasK5(g)) {
			return { kind: "nonplanar" };
		}

		// Check for K3,3 (complete bipartite 3,3)
		if (hasK33(g)) {
			return { kind: "nonplanar" };
		}

		// No forbidden subgraphs found, likely planar
		return { kind: "planar" };
	}

	// For larger graphs (n > 10), use sparse heuristic
	// Trees are always planar, sparse graphs likely planar
	if (m <= 2.5 * n - 5) {
		return { kind: "planar" };
	}

	// For moderately sized graphs (n <= 20), try extended forbidden subgraph check
	if (n <= 20) {
		// Check for K5 with extended search
		if (hasK5Extended(g)) {
			return { kind: "nonplanar" };
		}

		// Check for K3,3 with extended search
		if (hasK33Extended(g)) {
			return { kind: "nonplanar" };
		}
	}

	// Cannot determine for certain - too dense for heuristic
	return { kind: "unconstrained" };
};
