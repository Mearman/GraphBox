/**
 * geometric Graph Class Analyzers
 *
 * AUTO-GENERATED by scripts/codegen/generate-graph-classes.ts
 * DO NOT EDIT MANUALLY - But TODOs have been implemented
 */

import {
	buildAdjacencyList,
	hasInducedSubgraph,
	SUBGRAPH_PATTERNS
} from "../algorithms/extraction/forbidden-subgraphs.js";
import type {
	Planar
} from "../generation/spec/geometric.js";
import type { AnalyzerGraph , ComputePolicy } from "./types.js";

/**
 * Convert AnalyzerGraph to adjacency format for subgraph detection.
 * @param g
 */
const toAdjacencyFormat = (g: AnalyzerGraph): [Set<number>, Array<[number, number]>] => {
	const nodeIdMap = new Map<string, number>();
	for (const [index, v] of g.vertices.entries()) {
		nodeIdMap.set(v.id, index);
	}

	const vertexSet = new Set<number>(g.vertices.map((_, index) => index));
	const edgeList: Array<[number, number]> = [];

	for (const edge of g.edges) {
		if (edge.endpoints.length === 2 && !edge.directed) {
			const [sourceId, targetId] = edge.endpoints;
			const source = nodeIdMap.get(sourceId);
			const target = nodeIdMap.get(targetId);
			if (source !== undefined && target !== undefined && source !== target) {
				edgeList.push([source, target]);
			}
		}
	}

	return [vertexSet, edgeList];
};

/**
 * Check if graph contains K5 (complete graph on 5 vertices) as a subgraph.
 * @param g
 */
const hasK5 = (g: AnalyzerGraph): boolean => {
	const [vertexSet, edgeList] = toAdjacencyFormat(g);
	const adj = buildAdjacencyList(vertexSet, edgeList);
	return hasInducedSubgraph(adj, SUBGRAPH_PATTERNS.K5);
};

/**
 * Check if graph contains K3,3 (complete bipartite graph with 3 vertices per partition).
 *
 * K3,3 is the utility graph: 3 houses {0,1,2} and 3 utilities {3,4,5}.
 * Each house connects to all utilities, no edges within partitions.
 * @param g
 */
const hasK33 = (g: AnalyzerGraph): boolean => {
	const n = g.vertices.length;
	if (n < 6) return false;

	const [vertexSet, edgeList] = toAdjacencyFormat(g);
	const adj = buildAdjacencyList(vertexSet, edgeList);

	// K3,3 pattern: 6 vertices, 9 edges
	// Vertices {0,1,2} all connect to {3,4,5}
	const k33Pattern = {
		name: "K3_3",
		size: 6,
		edges: [
			[0, 3], [0, 4], [0, 5],
			[1, 3], [1, 4], [1, 5],
			[2, 3], [2, 4], [2, 5],
		] as Array<[number, number]>,
	};

	return hasInducedSubgraph(adj, k33Pattern);
};

/**
 * Compute Planar property from graph structure.
 * A graph is planar if it can be drawn in the plane without edge crossings.
 *
 * Uses Kuratowski's theorem: A graph is planar iff it contains no subdivision
 * of K5 or K3,3 (complete graph on 5 vertices or complete bipartite 3,3).
 *
 * Detection strategy:
 * 1. Trivial cases (n < 5): Always planar
 * 2. Edge count heuristic: If m > 3n - 6, then nonplanar (necessary condition)
 * 3. For small graphs (n <= 10): Check for K5 and K3,3 subgraphs
 * 4. For large graphs: Return unconstrained if heuristic passes
 *
 * @param g - Analyzer graph
 * @param _policy - Computation policy (unused)
 * @returns Planar property: "planar", "nonplanar", or "unconstrained"
 */
export const computePlanar = (
	g: AnalyzerGraph,
	_policy?: ComputePolicy
): Planar => {
	// Skip directed graphs
	if (g.edges.some(e => e.directed)) {
		return { kind: "unconstrained" };
	}

	const n = g.vertices.length;

	// Trivial cases
	if (n === 0) return { kind: "planar" };
	if (n === 1) return { kind: "planar" };
	if (n === 2) return { kind: "planar" };
	if (n === 3) return { kind: "planar" };
	if (n === 4) return { kind: "planar" };

	// Count undirected binary edges (excluding self-loops)
	let m = 0;
	for (const edge of g.edges) {
		if (edge.endpoints.length === 2 && !edge.directed) {
			const [u, v] = edge.endpoints;
			if (u !== v) {
				m++;
			}
		}
	}

	// Edge count heuristic: For planar graphs, m <= 3n - 6 (for n >= 3)
	// If m > 3n - 6, the graph is definitely nonplanar
	const maxEdges = 3 * n - 6;
	if (m > maxEdges) {
		return { kind: "nonplanar" };
	}

	// For small graphs, check for forbidden subgraphs K5 and K3,3
	if (n <= 10) {
		// Check for K5 (complete graph on 5 vertices)
		if (hasK5(g)) {
			return { kind: "nonplanar" };
		}

		// Check for K3,3 (complete bipartite 3,3)
		if (hasK33(g)) {
			return { kind: "nonplanar" };
		}

		// No forbidden subgraphs found, likely planar
		return { kind: "planar" };
	}

	// For large graphs, we can't exhaustively check without a full planarity test
	// Return unconstrained if edge count heuristic passes
	return { kind: "unconstrained" };
};
