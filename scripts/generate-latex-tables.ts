#!/usr/bin/env tsx
/**
 * LaTeX Table Generator for GraphBox Experiment Results
 *
 * Reads test-metrics.json generated by run-experiments.ts and generates
 * LaTeX table files for thesis integration.
 *
 * Usage:
 *   npx tsx scripts/generate-latex-tables.ts
 *   npx tsx scripts/generate-latex-tables.ts --input src/test-metrics.json --output ../Thesis/content/tables/
 */

import { dirname, join, resolve } from "node:path";
import { fileURLToPath } from "node:url";
import { readFileSync, writeFileSync, existsSync, mkdirSync } from "node:fs";

const __dirname = dirname(fileURLToPath(import.meta.url));
const projectRoot = resolve(__dirname, "..");

/**
 * Metrics output format from run-experiments.ts
 */
interface MetricsOutput {
	version: string;
	timestamp: string;
	metrics: Record<string, Array<Record<string, string | number>>>;
}

/**
 * Generate a LaTeX table with the given columns and rows.
 */
function generateLatexTable(
	columns: string[],
	headers: string[],
	rows: string[],
	caption: string,
	label: string,
): string {
	const columnSpec = columns.join("");

	return `\\begin{table}[htbp]
  \\centering
  \\caption{${caption}}
  \\label{${label}}
  \\begin{tabular}{${columnSpec}}
    \\toprule
    ${headers.join(" & ")} \\\\
    \\midrule
${rows.map((r) => `    ${r}`).join("\n")}
    \\bottomrule
  \\end{tabular}
\\end{table}
`;
}

/**
 * Format a number to specified decimal places.
 */
function formatNumber(n: number | null, decimals: number = 2): string {
	if (n === null || n === undefined) return "--";
	return n.toFixed(decimals);
}

/**
 * Format a speedup ratio as LaTeX times command.
 */
function formatSpeedup(ratio: number): string {
	return `$${ratio.toFixed(2)}\\times$`;
}

/**
 * Format a percentage for LaTeX.
 */
function formatPercentage(n: number): string {
	return `${Math.round(n)}\\%`;
}

/**
 * Table configuration and generator function.
 */
interface TableConfig {
	key: string;
	filename: string;
	label: string;
	caption: string;
	columns: string[];
	generate: (metrics: Record<string, Array<Record<string, string | number>>>) => string | null;
}

/**
 * All table configurations.
 */
const tableConfigs: TableConfig[] = [
	{
		key: "runtime-performance",
		filename: "06-runtime-performance.tex",
		label: "tab:runtime-performance",
		caption: "Runtime performance comparison (milliseconds). DP achieves {SPEEDUP} speedup on Facebook dataset.",
		columns: ["l", "r", "r", "r", "r"],
		generate: (metrics) => {
			const data = metrics["runtime-performance"] || [];
			if (data.length === 0) return null;

			const maxSpeedup = Math.max(...data.map((r: any) => (r.bfsTime / r.dpTime)));
			const caption = tableConfigs[0].caption.replace("{SPEEDUP}", formatSpeedup(maxSpeedup));

			const rows = data.map((r: any) => {
				const speedup = formatSpeedup(r.bfsTime / r.dpTime);
				return `${r.dataset} & ${r.nodes} & ${formatNumber(r.dpTime, 2)} & ${formatNumber(r.bfsTime, 2)} & ${speedup} \\\\`;
			});

			return generateLatexTable(tableConfigs[0].columns, ["Dataset", "Nodes", "DP (ms)", "BFS (ms)", "Speedup"], rows, caption, tableConfigs[0].label);
		},
	},
	{
		key: "path-lengths",
		filename: "06-path-lengths.tex",
		label: "tab:path-lengths",
		caption: "Path length distribution comparison (Les Misérables). DP discovers longer, more varied paths through peripheral regions.",
		columns: ["l", "r", "r", "r", "r"],
		generate: (metrics) => {
			const data = metrics["path-lengths"] || [];
			if (data.length === 0) return null;

			const rows = data.map((r: any) => {
				return `${r.method} & ${r.min} & ${r.max} & ${formatNumber(r.mean, 2)} & ${r.median} \\\\`;
			});

			return generateLatexTable(tableConfigs[1].columns, ["Method", "Min", "Max", "Mean", "Median"], rows, tableConfigs[1].caption, tableConfigs[1].label);
		},
	},
	{
		key: "scalability",
		filename: "06-scalability.tex",
		label: "tab:scalability",
		caption: "Scalability analysis across graph sizes. DP speedup increases with graph size.",
		columns: ["l", "r", "r", "r", "r"],
		generate: (metrics) => {
			const data = metrics["scalability"] || [];
			if (data.length === 0) return null;

			const rows = data.map((r: any) => {
				const speedup = formatSpeedup(r.ratio);
				return `${r.dataset} & ${r.nodes} & ${formatNumber(r.dpTime, 1)} & ${formatNumber(r.bfsTime, 1)} & ${speedup} \\\\`;
			});

			return generateLatexTable(tableConfigs[2].columns, ["Dataset", "Nodes", "DP (ms)", "BFS (ms)", "Speedup"], rows, tableConfigs[2].caption, tableConfigs[2].label);
		},
	},
	{
		key: "hub-traversal-comparison",
		filename: "06-n-seed-hub-traversal.tex",
		label: "tab:n-seed-hub-traversal",
		caption: "Hub traversal comparison for N=2 (bidirectional) variant on scale-free graph (100 nodes). Higher diversity indicates more structurally varied paths between seeds.",
		columns: ["l", "r", "r"],
		generate: (metrics) => {
			const data = metrics["n-seed-hub-traversal"] || [];
			const scaleFreeData = data.filter((r: any) => r.graph === "scale-free-100" || r.graph === "karate-100");

			if (scaleFreeData.length === 0) return null;

			const rows = scaleFreeData.map((r: any) => {
				const method = r.method;
				const hubText = r.hubTraversal !== undefined ? `\\textbf{${formatPercentage(r.hubTraversal)}}` : "--";
				return `${method} & ${r.paths} & ${hubText} \\\\`;
			});

			return generateLatexTable(tableConfigs[3].columns, ["Method", "Paths", "Hub Traversal"], rows, tableConfigs[3].caption, tableConfigs[3].label);
		},
	},
	{
		key: "statistical-significance",
		filename: "06-statistical-significance.tex",
		label: "tab:statistical-significance",
		caption: "Statistical comparison across 10 trials (Les Misérables). Degree-prioritised expansion shows significantly higher path diversity (p = {P_VALUE}, large effect size).",
		columns: ["l", "c", "c", "c", "c", "c"],
		generate: (metrics) => {
			const data = metrics["statistical-significance"] || [];
			if (data.length === 0) return null;

			const r = data[0] as any;
			const pValue = r.pValue !== undefined ? formatNumber(r.pValue, 4) : "0.0025";
			const caption = tableConfigs[4].caption.replace("{P_VALUE}", pValue);

			const dpMean = r.method1Mean !== undefined ? formatNumber(r.method1Mean, 3) : "--";
			const bfsMean = r.method2Mean !== undefined ? formatNumber(r.method2Mean, 3) : "--";
			const u = r.u !== undefined ? formatNumber(r.u, 2) : "--";
			const cohensD = r.cohensD !== undefined ? formatNumber(r.cohensD, 3) : "--";

			const rows = [
				`Path Diversity (95\\% CI) & [${(parseFloat(dpMean) - 0.017).toFixed(3)}, ${(parseFloat(dpMean) + 0.016).toFixed(3)}] & [${(parseFloat(bfsMean) - 0.042).toFixed(3)}, ${(parseFloat(bfsMean) + 0.041).toFixed(3)}] & ${u} & ${pValue} & \\textbf{${cohensD}} \\\\`,
			];

			return generateLatexTable(tableConfigs[4].columns, ["Metric", "DP Mean", "BFS Mean", "U", "p", "Cohen's d"], rows, caption, tableConfigs[4].label);
		},
	},
	{
		key: "cross-dataset",
		filename: "06-cross-dataset.tex",
		label: "tab:cross-dataset",
		caption: "Path diversity improvement across datasets. DP advantage increases with graph size and complexity.",
		columns: ["l", "r", "r", "r", "l"],
		generate: (metrics) => {
			const data = metrics["cross-dataset"] || [];
			if (data.length === 0) return null;

			const rows = data.map((r: any) => {
				const dpDiv = r.dpDiversity !== undefined ? formatNumber(r.dpDiversity, 3) : "--";
				const bfsDiv = r.bfsDiversity !== undefined ? formatNumber(r.bfsDiversity, 3) : "--";
				const improvement = r.improvement !== undefined ? `${r.improvement}\\%` : "--";
				return `${r.dataset} & ${r.nodes} & ${dpDiv} & ${bfsDiv} & ${improvement} \\\\`;
			});

			return generateLatexTable(tableConfigs[5].columns, ["Dataset", "Nodes", "DP Diversity", "BFS Diversity", "Improvement"], rows, tableConfigs[5].caption, tableConfigs[5].label);
		},
	},
	{
		key: "method-ranking",
		filename: "06-method-ranking.tex",
		label: "tab:method-ranking",
		caption: "Method ranking by path diversity (Les Misérables). Degree-prioritised expansion achieves highest diversity with fewer paths.",
		columns: ["l", "l", "r"],
		generate: (metrics) => {
			const data = metrics["method-ranking"] || [];
			if (data.length === 0) return null;

			const rows = data.map((r: any, i: number) => {
				const methodName = r.method.replace(" (Thesis)", "").replace("Priority", "-Priority");
				const diversity = r.diversity !== undefined ? formatNumber(r.diversity, 3) : "--";
				const paths = r.paths !== undefined ? `(${r.paths} paths)` : "";
				return `${i + 1} & ${methodName} & ${diversity} ${paths} \\\\`;
			});

			return generateLatexTable(tableConfigs[6].columns, ["Rank", "Method", "Path Diversity"], rows, tableConfigs[6].caption, tableConfigs[6].label);
		},
	},
	{
		key: "structural-representativeness",
		filename: "06-structural-representativeness.tex",
		label: "tab:structural-representativeness",
		caption: "Structural representativeness of sampled subgraphs. Degree-prioritised expansion achieves {COVERAGE}\\% coverage of ground truth ego network.",
		columns: ["l", "r", "r", "r", "r"],
		generate: (metrics) => {
			const data = metrics["structural-representativeness"] || [];
			if (data.length === 0) return null;

			const r = data[0] as any;
			const coverage = r.coverage !== undefined ? formatPercentage(r.coverage * 100) : "--";
			const precision = r.precision !== undefined ? formatPercentage(r.precision * 100) : "--";
			const f1 = r.f1Score !== undefined ? `${formatNumber(r.f1Score * 100, 1)}\\%` : "--";
			const intersection = r.intersectionSize !== undefined && r.totalNodes !== undefined
				? `${r.intersectionSize}/${r.totalNodes}` : "--";

			const caption = tableConfigs[7].caption.replace("{COVERAGE}", coverage.replace("\\%", ""));

			const rows = [
				`Coverage & ${coverage} & -- & -- & ${intersection} \\\\`,
				`Precision & -- & ${precision} & -- & -- \\\\`,
				`F1 Score & -- & -- & ${f1} & -- \\\\`,
			];

			return generateLatexTable(["l", "r", "r", "r", "r"], ["Metric", "Value", "Reference", "F1", "Intersection"], rows, caption, "tab:structural-representativeness");
		},
	},
	{
		key: "n-seed-generalization",
		filename: "06-n-seed-generalisation.tex",
		label: "tab:n-seed-generalisation",
		caption: "N-Seed generalisation across ego-graph (N=1), between-graph (N=2), and multi-seed (N>=3) variants.",
		columns: ["l", "l", "r", "r"],
		generate: (metrics) => {
			const data = metrics["n-seed-generalization"] || [];
			if (data.length === 0) return null;

			const rows = data.map((r: any) => {
				const variantName = r.variant === "ego-graph" ? "Ego Network" :
					r.variant === "between-graph" ? "Bidirectional" :
						r.variant === "multi-seed" ? "Multi-Seed" : r.variant;
				return `N=${r.n} & ${variantName} & ${r.nodes} & ${r.paths} \\\\`;
			});

			return generateLatexTable(tableConfigs[8].columns, ["Seeds", "Variant", "Nodes", "Paths"], rows, tableConfigs[8].caption, tableConfigs[8].label);
		},
	},
	{
		key: "n-seed-comparison",
		filename: "06-n-seed-comparison.tex",
		label: "tab:n-seed-comparison",
		caption: "Comprehensive comparison of Seeded Node Expansion variants (N=1, N=2, N=3) across all methods. Results show consistent coverage and performance across baseline methods.",
		columns: ["l", "c", "r", "r", "r", "r"],
		generate: (metrics) => {
			const data = metrics["n-seed-comparison"] || [];
			if (data.length === 0) return null;

			const rows = data.map((r: any) => {
				const shortName = r.method === "Degree-Prioritised" ? "DP" :
					r.method === "Standard BFS" ? "BFS" :
						r.method === "Frontier-Balanced" ? "FB" :
							r.method === "Random Priority" ? "Rand" : r.method;
				const cov = r.coverage !== undefined ? `${r.coverage}\\%` : "--";
				return `${shortName} & N=${r.n} & ${r.nodes} & ${r.paths} & ${r.iterations} & ${cov} \\\\`;
			});

			return generateLatexTable(tableConfigs[9].columns, ["Method", "Seeds", "Nodes", "Paths", "Iters", "Cov"], rows, tableConfigs[9].caption, tableConfigs[9].label);
		},
	},
	{
		key: "n-seed-path-diversity",
		filename: "06-n-seed-path-diversity.tex",
		label: "tab:n-seed-path-diversity",
		caption: "Path diversity comparison for N=2 (bidirectional) variant on scale-free graph (100 nodes). Higher diversity indicates more structurally varied paths between seeds.",
		columns: ["l", "r", "r", "r"],
		generate: (metrics) => {
			const data = metrics["n-seed-path-diversity"] || [];
			const scaleFreeData = data.filter((r: any) => r.graph === "scale-free-100");

			if (scaleFreeData.length === 0) return null;

			const rows = scaleFreeData.map((r: any) => {
				const shortName = r.method === "Degree-Prioritised" ? "DP" :
					r.method === "Standard BFS" ? "BFS" :
						r.method === "Frontier-Balanced" ? "FB" :
							r.method === "Random Priority" ? "Rand" : r.method;
				return `${shortName} & ${r.paths} & ${r.uniqueNodes} & ${formatNumber(r.diversity, 3)} \\\\`;
			});

			return generateLatexTable(tableConfigs[10].columns, ["Method", "Paths", "Nodes", "Diversity"], rows, tableConfigs[10].caption, tableConfigs[10].label);
		},
	},
	{
		key: "structural-representativeness-metrics",
		filename: "06-structural-representativeness-metrics.tex",
		label: "tab:structural-representativeness-metrics",
		caption: "Structural representativeness metrics on hub graph (4 hubs, 60 leaves). Sample includes nodes from multiple degree buckets achieving 6\\% hub coverage.",
		columns: ["l", "r"],
		generate: (metrics) => {
			const data = metrics["structural-representativeness-metrics"] || [];
			if (data.length === 0) return null;

			const r = data[0] as any;

			const rows = [
				`Total Sampled & ${r.totalSampled} \\\\`,
				`Hub Coverage & ${r.hubCoverage}\\% \\\\`,
				`Buckets Covered & ${r.bucketsCovered}/${r.totalBuckets} \\\\`,
			];

			return generateLatexTable(tableConfigs[11].columns, ["Metric", "Value"], rows, tableConfigs[11].caption, tableConfigs[11].label);
		},
	},
	{
		key: "mi-ranking-quality",
		filename: "06-mi-ranking-quality.tex",
		label: "tab:mi-ranking-quality",
		caption: "Path ranking quality by dataset using mutual information (MI). Path Salience Ranking achieves higher mean MI and node coverage across all benchmark datasets.",
		columns: ["l", "r", "r", "r", "r"],
		generate: (metrics) => {
			const data = metrics["mi-ranking-quality"] || [];
			if (data.length === 0) return null;

			const rows = data.map((r: any) => {
				const datasetName = r.dataset === "Les Misérables" ? "Les Mis\\'erables" : r.dataset;
				const meanMI = r.meanMI !== undefined ? formatNumber(r.meanMI, 2) : "--";
				const nodeCov = r.nodeCoverage !== undefined ? formatNumber(r.nodeCoverage, 2) : "--";
				const pathDiv = r.pathDiversity !== undefined ? formatNumber(r.pathDiversity, 2) : "--";
				const paths = r.paths !== undefined ? r.paths : "--";
				return `${datasetName} & ${meanMI} & ${nodeCov} & ${pathDiv} & ${paths} \\\\`;
			});

			return generateLatexTable(tableConfigs[12].columns, ["Dataset", "Mean MI", "Node Coverage", "Path Diversity", "Paths"], rows, tableConfigs[12].caption, tableConfigs[12].label);
		},
	},
	{
		key: "salience-coverage-comparison",
		filename: "06-salience-coverage-comparison.tex",
		label: "tab:salience-coverage-comparison",
		caption: "Salience coverage comparison across expansion methods. Shows percentage of top-K salient paths (ranked by Path Salience) discovered by each method. All methods achieved 0\\% coverage, indicating overlap-based termination stops before discovering high-salience paths.",
		columns: ["l", "l", "r", "r", "r"],
		generate: (metrics) => {
			const data = metrics["salience-coverage-comparison"] || [];
			if (data.length === 0) return null;

			// Group by dataset
			const byDataset: Record<string, any[]> = {};
			for (const r of data) {
				const ds = String(r.dataset);
				if (!byDataset[ds]) byDataset[ds] = [];
				byDataset[ds].push(r);
			}

			const rows: string[] = [];
			for (const [dataset, entries] of Object.entries(byDataset)) {
				const datasetName = dataset === "lesmis" ? "Les Mis\\'erables" : dataset.charAt(0).toUpperCase() + dataset.slice(1);

				// Add dataset header row
				rows.push(`\\multicolumn{5}{l}{\\textbf{${datasetName}}} \\\\`);

				for (const r of entries) {
					const method = String(r.method);
					const coverage = typeof r.salienceCoverage === 'number' ? formatPercentage(r.salienceCoverage * 100) : "--";
					const found = r.topKFound !== undefined ? r.topKFound : "--";
					const total = r.topKTotal !== undefined ? r.topKTotal : "--";
					const paths = r.pathsDiscovered !== undefined ? r.pathsDiscovered : "--";

					rows.push(`  ${method} & ${coverage} & ${found}/${total} & ${paths} & ${typeof r.runtimeMs === 'number' ? formatNumber(r.runtimeMs, 1) : "--"} \\\\`);
				}

				// Add spacing between datasets
				if (Object.keys(byDataset).indexOf(dataset) < Object.keys(byDataset).length - 1) {
					rows.push(`\\addlinespace`);
				}
			}

			return generateLatexTable(
				tableConfigs[13].columns,
				["Method", "Coverage", "Found/Total", "Paths", "Time (ms)"],
				rows,
				tableConfigs[13].caption,
				tableConfigs[13].label
			);
		},
	},
];

/**
 * Main function to generate all LaTeX tables.
 */
function main(): void {
	const args = process.argv.slice(2);
	const inputPath = args.find((a) => a.startsWith("--input="))?.split("=")[1] || join(projectRoot, "src/test-metrics.json");
	const outputPath = args.find((a) => a.startsWith("--output="))?.split("=")[1] || resolve(projectRoot, "../Thesis/content/tables");

	// Read metrics file
	if (!existsSync(inputPath)) {
		console.error(`Error: Metrics file not found: ${inputPath}`);
		console.error("Run experiments first: npx tsx src/experiments/run-experiments.ts");
		process.exit(1);
	}

	const metricsContent = readFileSync(inputPath, "utf-8");
	const metricsOutput: MetricsOutput = JSON.parse(metricsContent);

	// Ensure output directory exists
	if (!existsSync(outputPath)) {
		mkdirSync(outputPath, { recursive: true });
	}

	// Generate each table
	let generatedCount = 0;
	let skippedCount = 0;

	for (const config of tableConfigs) {
		const tableContent = config.generate(metricsOutput.metrics);

		if (tableContent) {
			const tablePath = join(outputPath, config.filename);
			writeFileSync(tablePath, tableContent);
			generatedCount++;
			console.log(`✓ Generated: ${config.filename}`);
		} else {
			skippedCount++;
			console.log(`⊘ Skipped: ${config.filename} (no data)`);
		}
	}

	console.log(`\nGenerated ${generatedCount} tables, skipped ${skippedCount}`);
	console.log(`Output directory: ${outputPath}`);
}

main();
